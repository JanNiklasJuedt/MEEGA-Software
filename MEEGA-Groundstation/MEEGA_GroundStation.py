#imports
#miscellaneous imports
from __future__ import annotations #for forward type references
from enum import IntEnum
from math import floor
from math import sin, radians
import numpy as np
import sys
import time

#import of qt modules
from PySide6.QtGui import (QAction, QActionGroup, QIcon, QImage, QPixmap, QPainter)
from PySide6.QtWidgets import (QApplication, QButtonGroup, QMainWindow, QDialog, QWidget, QVBoxLayout)
from PySide6.QtCore import (Signal, Slot, QTranslator, QLocale, QThread, QPointF, QObject)
from PySide6.QtCharts import (QChart, QChartView, QLineSeries, QValueAxis)

#imports from autogenerated ui-files
from MEEGA_mainWindow import *
from MEEGA_calibration import *
from MEEGA_startup import *
from MEEGA_Connection import *
from MEEGA_time import *
from MEEGA_documentation import *
from MEEGA_error import *
from MEEGA_controlPanel import *
from MEEGA_results import *
from MEEGA_calibration import *
from MEEGA_diagramSettings import *

#import from own data handling module with c functions
from MEEGA_PyDataHandling import *

#class to handle program settings
#keep track of diagram settings, program settings
class Settings:
    AUTOMATIC = 0
    MANUAL = 1
    FLIGHT = 1
    TEST = 0
    SERIAL = 0
    TCP = 1
    #diagram flags
    SELFSCALING = 0
    FIXEDVALUE = 1
    SCROLLING = 0
    EXPANDING = 1
    ALL = 0
    LO = 1
    SOE = 2
    defaultFilePath = "Default.meega"
    defaultLaunchTime = QTime(12,0,0)

    def __init__(self, locale: QLocale = None):
        if locale == None:
            self.locale = QLocale()
        else:
            self.locale = QLocale(locale)
        self.mode = self.TEST
        self.connectionMode = self.AUTOMATIC
        self.connectionType = self.SERIAL
        self.connector = "COM4"
        self.filePath = self.defaultFilePath
        self.launchTime = self.defaultLaunchTime
        self.pressureAxeMode = self.SELFSCALING
        self.temperatureAxeMode = self.SELFSCALING
        self.timespanMode = self.EXPANDING
        self.pressureAxeValue = 300
        self.temperatureAxeValue = 300
        self.scrollingTimeSeconds = 10
        self.expandFrom = self.ALL

#class to handle telecommands
class Telecommand(QObject):
    def __init__(self, collection):
        self.collection = collection
        self.sendCounter = 0
        self.expStartQueue = False #variable to queue another telecommand to deactivate experiment start after experiment start has been sent, is being set True in control panel after experiment start sendInit() is called

    #creating Telecommand in DataHandling, writing program mode (test/flight))
    def newTCFrame(self):
        self.tcframe = DataHandling.CreateTC()
        DataHandling.WriteFrame(self.tcframe, 0, self.collection.settings.mode)

    #initialize sending of 10 identical telecommands to ensure reception
    def sendInit(self):
        self.expStartQueue = False #reset to standard False, as sending dedicated turn off telecommands is unnecessary if one with additional changes is sent anyways
        self.sendCounter = 10

    #single sending step called by DataHandlingThread
    @Slot()
    def sendStep(self):
        if self.sendCounter > 0:
            DataHandling.AddFrame(self.tcframe)
            self.sendCounter -= 1
        #sending turn off of start signal if queued
        elif self.expStartQueue:
            self.newTCFrame()
            self.collection.controlPanel.updateTCFrame()
            self.sendInit()

#class to define the Main Window
class GSMain(QMainWindow):
    #Flags for status display
    ACTIVE = 1
    ISSUES = 2
    ISSUESSTM = 3
    INACTIVE = 0
    NOCONNECTION = 3
    def __init__(self, collection: ClassCollection):
        super().__init__()

        #importing visuals from the ui-file
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        #creating variables
        self.connectionStatus = self.NOCONNECTION
        self.collection = collection

        #creating local list of status display labels from ui files
        self.statusDisplay = [None]*22
        self.statusDisplay[0] = self.ui.statusLabelPAmbient
        self.statusDisplay[1] = self.ui.statusLabelTCompare
        self.statusDisplay[2] = self.ui.statusLabelPReservoir
        self.statusDisplay[3] = self.ui.statusLabelTReservoir
        self.statusDisplay[4] = self.ui.statusLabelPAccumulator
        self.statusDisplay[5] = self.ui.statusLabelTChamber1
        self.statusDisplay[6] = self.ui.statusLabelTChamber2
        self.statusDisplay[7] = self.ui.statusLabelPNozzle1
        self.statusDisplay[8] = self.ui.statusLabelTNozzle1
        self.statusDisplay[9] = self.ui.statusLabelPNozzle2
        self.statusDisplay[10] = self.ui.statusLabelTNozzle2
        self.statusDisplay[11] = self.ui.statusLabelPNozzle3
        self.statusDisplay[12] = self.ui.statusLabelTNozzle3
        self.statusDisplay[13] = self.ui.statusLabelServo
        self.statusDisplay[14] = self.ui.statusLabelValve
        self.statusDisplay[15] = self.ui.statusLabelLED
        self.statusDisplay[16] = self.ui.statusLabelPChip
        self.statusDisplay[17] = self.ui.statusLabelTChip
        self.statusDisplay[18] = self.ui.statusLabelMainboardT
        self.statusDisplay[19] = self.ui.statusLabelMainboardV
        self.statusDisplay[20] = self.ui.statusLabelLiftOff
        self.statusDisplay[21] = self.ui.statusLabelSOE

        #creating status pixmaps
        self.activepix = QPixmap("Ressources\\active.png")
        self.issuespix = QPixmap("Ressources\\issues.png")
        self.inactivepix = QPixmap("Ressources\\inactive.png")
        self.noconnectionpix = QPixmap("Ressources\\noconnection.png")

        self.scalePixmaps()
        
        #standard value for all displays is inactive (red)
        for statusLabel in self.statusDisplay:
            statusLabel.setPixmap(self.inactivepix_scaled)
        
        #initializing plots
        self.createPlots()

        self.setLocale(self.collection.settings.locale)

        #expanding tree for choosing displayed plots
        self.ui.treeWidget.expandAll()

        #creating the big logo
        self.logo = QPixmap("Ressources\\meega_logo_small.png")
        self.ui.label_logo.setPixmap(self.logo)

        #creating menubar actiongroups (for exclusivity of selected options)
        self.languageGroup = QActionGroup(self.ui.menuLanguage)
        self.languageGroup.setExclusive(True)
        for i in self.ui.menuLanguage.actions():
            self.languageGroup.addAction(i)
        self.modeGroup = QActionGroup(self.ui.menuStart)
        self.modeGroup.setExclusive(True)
        self.modeGroup.addAction(self.ui.actionFlight_Mode)
        self.modeGroup.addAction(self.ui.actionTest_Mode)
        self.connectionModeGroup = QActionGroup(self.ui.menuConnection)
        self.connectionModeGroup.addAction(self.ui.actionAutomatic)
        self.connectionModeGroup.addAction(self.ui.actionManual)
        
        #reference to the application object
        self.app = QApplication.instance()
    #internal functions

    def connect(self):
        #connection of signals and slots, called in late-init in ClassCollection after all components are created
        self.languageGroup.triggered.connect(self.languageChanges)
        self.ui.actionManual.triggered.connect(self.fetchSettings)
        self.ui.actionAutomatic.triggered.connect(self.fetchSettings)
        self.ui.actionFlight_Mode.triggered.connect(self.modeSwitched)
        self.ui.actionTest_Mode.triggered.connect(self.modeSwitched)
        self.ui.actionQuit.triggered.connect(self.collection.shutdown)
        self.ui.treeWidget.itemChanged.connect(self.onItemChanged)

    #override closeEvent to ensure proper thread termination and application exit when trying to close the main window
    def closeEvent(self, event):
        self.collection.shutdown()
        event.accept()
        super().closeEvent(event)

    def scalePixmaps(self):
            #adjust pixmap sizes to label sizes
            label_size = self.statusDisplay[0].size()
            circle_diameter = min(label_size.width(), label_size.height())
            self.activepix_scaled = self.activepix.scaled(circle_diameter, circle_diameter, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.issuespix_scaled = self.issuespix.scaled(circle_diameter, circle_diameter, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.inactivepix_scaled = self.inactivepix.scaled(circle_diameter, circle_diameter, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            #scale for connection status label
            connectionLabelSize = self.ui.connectionLabel.size()
            connectionCircle = min(connectionLabelSize.width(), connectionLabelSize.height())
            self.activepix_connection = self.activepix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.issuespix_connection = self.issuespix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.inactivepix_connection = self.inactivepix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.noconnectionpix_connection = self.noconnectionpix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)

    #override resizeEvent to rescale pixmaps when window size changes
    def resizeEvent(self, event):
            self.scalePixmaps()
            super().resizeEvent(event)

    def retranslateUi(self):
        self.ui.retranslateUi()

    #functionality for changing language not implemented yet
    def languageChanges(self):
        translator = QTranslator()
        locale = self.collection.settings.locale
        language = QLocale.languageToCode(locale.language())
        for i in self.languageGroup.actions():
            if i.property("data") == language:
                i.setChecked(True)
        #Baustelle:
        if translator.load(locale, "MEEGA_Language"):
            self.app.removeTranslator(translator)
            self.app.installTranslator(translator)
            self.retranslateUi(self)

    #functionality for changing connection mode, not implemented yet, not planning on implementing automatic connection handling
    def connectionModeChanges(self):
        if self.collection.settings.connectionMode == Settings.AUTOMATIC:
            self.ui.actionConnect.setEnabled(False)
            self.ui.actionRetry.setEnabled(False)
            self.ui.actionDisconnect.setEnabled(False)
        else:
            self.ui.actionConnect.setEnabled(True)
            self.ui.actionRetry.setEnabled(True)
            self.ui.actionDisconnect.setEnabled(True)
            self.ui.menuSettings.popup(self.ui.menuSettings.pos())
            self.ui.menuSettings.setActiveAction(self.ui.menuConnection.menuAction())
    def filePathChanges(self):
        pass

    #update of status displays according to current data in DataAccumulation, called every new frame
    @Slot()
    def displayStatus(self, index: int):
        #connection status
        match self.connectionStatus:
            case self.ACTIVE:
                self.ui.connectionLabel.setPixmap(self.activepix_connection)
            case self.ISSUES:
                self.ui.connectionLabel.setPixmap(self.issuespix_connection)
            case self.INACTIVE:
                self.ui.connectionLabel.setPixmap(self.inactivepix_connection)
            case self.NOCONNECTION:
                self.ui.connectionLabel.setPixmap(self.noconnectionpix_connection)

        #sensor / household status

        #fetching necessary data
        dataAccu = self.collection.dataAccumulation
        gatherIndex = self.collection.dataAccumulation.gatherIndex

        #fitting most recent status values from dataAccumulation into a single list with order according to statusDisplay list for handling via for loop
        statusList = np.concatenate((dataAccu.household[gatherIndex][0:DataAccumulation.sensorSize], dataAccu.household[gatherIndex][PyID.Nozzle_Servo:PyID.Sensorboard_T+1], dataAccu.household[gatherIndex][PyID.Mainboard_T:PyID.Mainboard_V+1], dataAccu.household[gatherIndex][PyID.Lift_Off:PyID.Start_Experiment+1]))
            
        #updating each label in statusDisplay according to statusList that was just created
        for i, display in enumerate(self.statusDisplay):
            match statusList[i]:
                case self.ACTIVE:
                    display.setPixmap(self.activepix_scaled)
                case self.ISSUES:
                    display.setPixmap(self.issuespix_scaled)
                case self.INACTIVE:
                    display.setPixmap(self.inactivepix_scaled)
                case self.ISSUESSTM:
                    display.setPixmap(self.issuespix_scaled)
            
        #special case for nozzle cover status display
        coverOpen = self.collection.dataAccumulation.household[gatherIndex][PyID.Nozzle_Open]
        coverClosed = self.collection.dataAccumulation.household[gatherIndex][PyID.Nozzle_Closed]
        if coverOpen and not coverClosed:
            self.ui.statusLabelCover.setPixmap(self.activepix_scaled)
        elif not coverOpen and coverClosed:
            self.ui.statusLabelCover.setPixmap(self.inactivepix_scaled)
        else:
            self.ui.statusLabelCover.setPixmap(self.issuespix_scaled)

    def createPlots(self):
        #time plot
        #create Line Series for each sensor
        #ambient pressure, compare temperature, accumulator pressure, accumulator temperature, chamber pressure, chamber temperature1, chamber temperature 2, nozzle 1 pressure, nozzle 1 temperature, nozzle 2 pressure, nozzle 2 temperature, nozzle 3 pressure, nozzle 3 temperature
        self.timeSeries = [QLineSeries() for _ in range(DataAccumulation.sensorSize)]

        #indices of pressure and temperature series f.e. for axis assignment
        self.pressureIndices = [0,2,4,7,9,11]
        self.temperatureIndices = [1,3,5,6,8,10,12]

        #value tracking for time plots
        self.timeHighestPres = 0 #keep track of highest pressure for self-scaling axes
        self.timeHighestTemp = 0 #keep track of highest temperature for self-scaling axes
        self.currentIndex = -1 #keep track of last index added to time plot for extendPlots function

        #create chart and disable legend
        self.timeChart = QChart()
        self.timeChart.legend().setVisible(False)

        #add series to chart
        for s in self.timeSeries:
            self.timeChart.addSeries(s)

        #create axes
        self.timeAxis = QValueAxis()
        self.timePressureAxis = QValueAxis()
        self.timeTemperatureAxis = QValueAxis()

        #label axes
        self.timeAxis.setTitleText("time in ms")
        self.timePressureAxis.setTitleText("pressure in Pa")
        self.timeTemperatureAxis.setTitleText("temperature in K")

        #set initial ranges
        self.timePressureAxis.setRange(0, self.collection.settings.pressureAxeValue)
        self.timeTemperatureAxis.setRange(0, self.collection.settings.temperatureAxeValue)
        self.timeAxis.setRange(0, 1)

        #add axes to chart
        self.timeChart.addAxis(self.timeAxis, Qt.AlignBottom)
        self.timeChart.addAxis(self.timePressureAxis, Qt.AlignLeft)
        self.timeChart.addAxis(self.timeTemperatureAxis, Qt.AlignRight)

        #attach axes to series
        for i, series in enumerate(self.timeSeries):
            if i in self.pressureIndices:
                series.attachAxis(self.timePressureAxis)
            else:
                series.attachAxis(self.timeTemperatureAxis)
            series.attachAxis(self.timeAxis)
            
        #create Layout
        self.timeLayout = QVBoxLayout(self.ui.timePlotGroupBox)
        self.timeLayout.setContentsMargins(0,0,0,0)

        #create ChartView and add to Layout
        self.timeChartView = QChartView(self.timeChart)
        self.timeChartView.setRenderHint(QPainter.Antialiasing)
        self.timeLayout.addWidget(self.timeChartView)

        #distance plot
        #create Line Series for pressure and temperature
        self.distancePSeries = QLineSeries()
        self.distanceTSeries = QLineSeries()

        #create Chart and add Series
        self.distanceChart = QChart()
        self.distanceChart.addSeries(self.distancePSeries)
        self.distanceChart.addSeries(self.distanceTSeries)

        #create axes
        self.distanceAxis = QValueAxis()
        self.distancePressureAxis = QValueAxis()
        self.distanceTemperatureAxis = QValueAxis()

        #label axes
        self.distancePressureAxis.setTitleText("pressure in Pa")
        self.distanceTemperatureAxis.setTitleText("temperature in K")

        #set initial ranges
        self.distanceAxis.setRange(0, 5)
        self.distancePressureAxis.setRange(0, self.collection.settings.pressureAxeValue)
        self.distanceTemperatureAxis.setRange(0, self.collection.settings.temperatureAxeValue)

        #add axes to chart
        self.distanceChart.addAxis(self.distancePressureAxis, Qt.AlignBottom)
        self.distanceChart.addAxis(self.distanceTemperatureAxis, Qt.AlignTop)
        self.distanceChart.addAxis(self.distanceAxis, Qt.AlignLeft)

        #attach axes to series
        self.distancePSeries.attachAxis(self.distancePressureAxis)
        self.distancePSeries.attachAxis(self.distanceAxis)
        self.distanceTSeries.attachAxis(self.distanceTemperatureAxis)
        self.distanceTSeries.attachAxis(self.distanceAxis)
        
        #create Layout
        self.distanceLayout = QVBoxLayout(self.ui.distancePlotGroupBox)
        self.distanceLayout.setContentsMargins(0,0,0,0)

        #add Chart to ChartView and Layout
        self.distanceChartView = QChartView(self.distanceChart)
        self.distanceChartView.setRenderHint(QPainter.Antialiasing)
        self.distanceLayout.addWidget(self.distanceChartView)

        self.connectItemsToSeries()
        #self.repaintPlots()

    def extendPlots(self, index: int):
        #fetching necessary data
        settings = self.collection.settings
        dataAccu = self.collection.dataAccumulation

        #distance plot
        self.distancePSeries.clear()
        self.distanceTSeries.clear()
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Accumulator_Pressure], 0)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Chamber_Pressure], 1)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_1_Pressure], 3)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_2_Pressure], 4)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_3_Pressure], 5)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Accumulator_Temperature], 0)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Chamber_Temperature_1], 1)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Chamber_Temperature_2], 2)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_1_Temperature], 3)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_2_Temperature], 4)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_3_Temperature], 5)

        #skip if expanding mode needs an event that hasnt happened yet ie. expanding mode with LO or SOE as starting point with no recorded index (-1)
        if not (settings.timespanMode == Settings.EXPANDING and(
            (settings.expandFrom == Settings.LO and dataAccu.liftOffIndex == -1) or 
            (settings.expandFrom == Settings.SOE and dataAccu.startOfExperimentIndex == -1)
        )):
            #time plot
            #while loop to add all new data points until currentIndex matches gatherIndex from dataAccumulation
            while self.currentIndex < dataAccu.gatherIndex:
                self.currentIndex += 1

                #for loop for all sensor series in time plot
                for i, series in enumerate(self.timeSeries):

                    #if in scrolling mode, removing oldest point as long as covered timespand exceeds specified scrolling time from settings
                    if settings.timespanMode == Settings.SCROLLING:
                        while (series.at(series.count()-1).x() - series.at(0).x()) > settings.scrollingTimeSeconds*1000:
                            series.remove(0)

                    #"index" is given by the signal that calls extendPlots and is the index in the dataAccumulation list of the newly added sensor Data
                    #if index matches currentIndex, simply append new data point
                    if index == self.currentIndex:
                        series.append(dataAccu.household[index][PyID.System_Time], dataAccu.sensorData[index][i])

                    #if index does not match currentIndex, calculate correct insert index
                    else:
                        #initialize insertIndex, mark as invalid with -1
                        insertIndex = -1

                        #in expanding mode, make sure that the data point is from after according event, calculate insert index by subtracting index of said event (or 0 if showing all points is selected)
                        if settings.timespanMode == Settings.EXPANDING:
                            if settings.expandFrom == Settings.LO and index > dataAccu.liftOffIndex:
                                insertIndex = index - dataAccu.liftOffIndex
                            elif settings.expandFrom == Settings.SOE and index > dataAccu.startOfExperimentIndex:
                                insertIndex = index - dataAccu.startOfExperimentIndex
                            elif settings.expandFrom == Settings.ALL:
                                insertIndex = index

                        #in scrolling mode, calculate insert index by subtracting the the global index of first data point currently displayed in the chart (highgest current globalIndex (gatherIndex) - number of points currently in series)
                        elif settings.timespandMode == Settings.SCROLLING:
                            insertIndex = index - (dataAccu.gatherIndex - series.count())

                        #insert data point at calculated index if valid
                        if insertIndex >= 0:
                            series.insert(insertIndex, QPointF(dataAccu.household[index][PyID.System_Time], dataAccu.sensorData[index][i]))

                    #save highest values for scaling of axes
                    if i in self.pressureIndices: #pressure Value
                        if dataAccu.sensorData[index][i] > self.timeHighestPres:
                            self.timeHighestPres = dataAccu.sensorData[index][i]
                    else: #temperature Value
                        if dataAccu.sensorData[index][i] > self.timeHighestTemp:
                            self.timeHighestTemp = dataAccu.sensorData[index][i]

                #adjust time axis range from first to last point in arbitrarily chosen series (here: first series, ambient pressure)
                self.timeAxis.setRange(self.timeSeries[0].at(0).x(), self.timeSeries[0].at(self.timeSeries[0].count()-1).x())

        #update axes if one of them is in self-scaling mode
        if settings.temperatureAxeMode == Settings.SELFSCALING or settings.pressureAxeMode == Settings.SELFSCALING:
            self.updateAxes()

        #self.repaintPlots()

    #not currently in use, intended for forcing plot repaints only when necessary to save comptuing resources
    def repaintPlots(self):
        self.timeChartView.setUpdatesEnabled(True)
        self.timeChartView.blockSignals(False)
        self.distanceChartView.setUpdatesEnabled(True)
        self.distanceChartView.scene().blockSignals(False)
        self.distanceChartView.repaint()
        self.timeChartView.repaint()
        self.distanceChartView.setUpdatesEnabled(False)
        self.distanceChartView.scene().blockSignals(True)
        self.timeChartView.setUpdatesEnabled(False)
        self.timeChartView.blockSignals(True)

    #function to update axes ranges according to current highest values and settings
    def updateAxes(self):
        #fetching necessary data
        settings = self.collection.settings

        #if axes are in fixed-value mode, set range from 0 to specified value in settings
        if settings.pressureAxeMode == Settings.FIXEDVALUE:
            self.timePressureAxis.setRange(0, settings.pressureAxeValue)
            self.distancePressureAxis.setRange(0, settings.pressureAxeValue)

        #if axes are in self-scaling mode, set range from 0 to highest recorded value (compute it on spot for distance plot)
        else:
            self.timePressureAxis.setRange(0, self.timeHighestPres)
            self.distancePressureAxis.setRange(0, max(point.x() for point in self.distancePSeries.points()))

        #same for temperature axes
        if settings.temperatureAxeMode == Settings.FIXEDVALUE:
            self.timeTemperatureAxis.setRange(0, settings.temperatureAxeValue)
            self.distanceTemperatureAxis.setRange(0, settings.temperatureAxeValue)
        else:
            self.timeTemperatureAxis.setRange(0, self.timeHighestTemp)
            self.distanceTemperatureAxis.setRange(0, max(point.x() for point in self.distanceTSeries.points()))

    #connect index value of series to according tree item so that it can be called in onItemChanged, when user checks or unchecks items in the tree
    def connectItemsToSeries(self):
        tree = self.ui.treeWidget
        tree.topLevelItem(0).child(0).child(3).setData(0, Qt.UserRole, 0)  # Ambient Pressure
        tree.topLevelItem(0).child(1).child(3).setData(0, Qt.UserRole, 1)  # Compare Temperature
        tree.topLevelItem(0).child(0).child(2).setData(0, Qt.UserRole, 2)  # Accumulator Pressure
        tree.topLevelItem(0).child(1).child(2).setData(0, Qt.UserRole, 3)  # Accumulator Temperature
        tree.topLevelItem(0).child(0).child(1).setData(0, Qt.UserRole, 4)  # Chamber Pressure
        tree.topLevelItem(0).child(1).child(1).child(0).setData(0, Qt.UserRole, 5)  # Chamber 1 Temperature
        tree.topLevelItem(0).child(1).child(1).child(1).setData(0,Qt.UserRole,6) #Chamber 2 Temperature
        tree.topLevelItem(0).child(0).child(0).child(0).setData(0, Qt.UserRole, 7)  # Nozzle 1 Pressure
        tree.topLevelItem(0).child(1).child(0).child(0).setData(0, Qt.UserRole, 8)  # Nozzle 1 Temperature
        tree.topLevelItem(0).child(0).child(0).child(1).setData(0, Qt.UserRole, 9)  # Nozzle 2 Pressure
        tree.topLevelItem(0).child(1).child(0).child(1).setData(0, Qt.UserRole, 10)  # Nozzle 2 Temperature
        tree.topLevelItem(0).child(0).child(0).child(2).setData(0, Qt.UserRole, 11)  # Nozzle 3 Pressure
        tree.topLevelItem(0).child(1).child(0).child(2).setData(0, Qt.UserRole, 12)  # Nozzle 3 Temperature

    #external functions (slots)

    #onNewFrame is called by Signal in DataAccumulation every time a new frame has been added, calls extendPlots, which is necessary updates for every new frame
    @Slot(int)
    def onNewFrame(self, index: int):
        self.extendPlots(index)

    #slot for mode switching (flight/test) from menubar
    @Slot()
    def modeSwitched(self):
        if self.modeGroup.checkedAction() == self.ui.actionFlight_Mode:
            #update settings value
            self.collection.settings.mode = Settings.FLIGHT

            #update label in main window
            self.ui.label_mode.setText("Flight Mode")

            #disable button for opening control panel
            self.ui.actionControl_Panel.setEnabled(False)

            #clear and hide control panel
            self.collection.controlPanel.clearPanel()
            self.collection.controlPanel.hide()

        else:
            #update settings value
            self.collection.settings.mode = Settings.TEST

            #update label in main window
            self.ui.label_mode.setText("Test Mode")

            #enable button for opening control panel
            self.ui.actionControl_Panel.setEnabled(True)

        #send telecommand with updated mode
        self.collection.telecommand.newTCFrame()
        self.collection.telecommand.sendInit()

    #function only used for connection mode changes from menubar, not implemented yet, not planned to be implemented, outdated
    @Slot()
    def fetchSettings(self):
        if self.connectionModeGroup.checkedAction() == self.ui.actionAutomatic:
            connectionMode = Settings.AUTOMATIC
        else:
            connectionMode = Settings.MANUAL
        self.collection.settings.connectionMode = connectionMode
        self.connectionModeChanges()

    #function to apply settings from collection to main window ui elements, called after startup dialog is closed
    @Slot()
    def applySettings(self):
        if self.collection.settings.connectionMode == Settings.AUTOMATIC:
            self.ui.actionAutomatic.setChecked(True)
        else:
            self.ui.actionManual.setChecked(True)
        if self.collection.settings.mode == Settings.FLIGHT:
            self.ui.actionFlight_Mode.setChecked(True)
        else:
            self.ui.actionTest_Mode.setChecked(True)
        self.setLocale(self.collection.settings.locale)
        self.languageChanges()
        self.modeSwitched()
        self.connectionModeChanges()
        self.filePathChanges()

    #override of itemChanged signal from treeWidget in main window, called when user checks or unchecks an item in the tree to add or remove the according series from the time plot
    @Slot(QTreeWidgetItem, int)
    def onItemChanged(self, item, column):
        #get series index from item data
        if item.data(0, Qt.UserRole) is None:
            return
        seriesIndex = item.data(0, Qt.UserRole)

        #get series from series index
        series = self.timeSeries[seriesIndex]

        #add or remove series from chart according to check state of item
        #add if checked and not already added
        if item.checkState(0) == Qt.Checked:
            if series not in self.timeChart.series():
                self.timeChart.addSeries(series)

                #time axis
                series.attachAxis(self.timeAxis)

                #add correct value axis
                if seriesIndex in self.pressureIndices:
                    series.attachAxis(self.timePressureAxis)
                else:
                    series.attachAxis(self.timeTemperatureAxis)

        #remove if unchecked and currently added
        else:
            if series in self.timeChart.series():
                self.timeChart.removeSeries(series)
    
    #slot to replace series, called by PlotWorker Thread when needing to replace entire series
    @Slot(int, list)
    def replaceSeries(self, seriesIndex: int, points: list[QPointF]):
        self.timeSeries[seriesIndex].replace(points)

    #slot to clear series, called by PlotWorker Thread when needing to clear entire series
    @Slot(int)
    def clearSeries(self, seriesIndex: int):
        self.timeSeries[seriesIndex].clear()
    
    #update currentIndex, highest values after plot Rebuild, called by PlotWorker Thread
    @Slot(int, float, float)
    def updatePlotMetrics(self, currentIndex: int, highestPres: float, highestTemp: float):
        self.currentIndex = currentIndex
        self.timeHighestPres = highestPres
        self.timeHighestTemp = highestTemp

    #slot to set connection status, called by DataAccumulation when connection status changes, needed for proper decoupling of threads
    @Slot(int)
    def setConnectionStatus(self, status: int):
        self.connectionStatus = status

#class to define the startup dialog window
class GSStart(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_StartDialog()
        self.ui.setupUi(self)
        self.collection = collection
        self.ui.languageComboBox.setItemData(0, "en")
        self.ui.languageComboBox.setItemData(1, "de")
        self.ui.connectionComboBox.setItemData(0,Settings.AUTOMATIC)
        self.ui.connectionComboBox.setItemData(1,Settings.MANUAL)
        self.ui.modeComboBox.setItemData(0, Settings.TEST)
        self.ui.modeComboBox.setItemData(1, Settings.FLIGHT)

        #if dialog i rejected, call shutdown of collection to terminate application
        self.rejected.connect(self.collection.shutdown)
        #if dialog is accepted, fetch settings from ui elements
        self.accepted.connect(self.fetchSettings)

    #override closeEvent to ensure proper thread termination and application exit when trying to close the dialog
    def closeEvent(self, event):
        self.collection.shutdown()
        event.accept()
        super().closeEvent(event)
    
    #fetch settings from ui elements and store them in settings
    @Slot()
    def fetchSettings(self):
        self.collection.settings.language = self.ui.languageComboBox.currentData()
        self.collection.settings.connectionMode = self.ui.connectionComboBox.currentData()
        self.collection.settings.mode = self.ui.modeComboBox.currentData()
        self.collection.settings.filepath = self.ui.saveFileEdit.text()
        self.collection.settings.launchTime = self.ui.launchTimeTimeEdit.time()

#class that defines window for defining (approximate) launch time
class GSLaunchTime(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_LaunchTimeDialog()
        self.ui.setupUi(self)
        self.collection = collection

        #if dialog is accepted, fetch launch time from ui element
        self.accepted.connect(self.fetchSettings)
    
    #fetch launch time from ui element and store it in settings
    @Slot()
    def fetchSettings(self):
        self.collection.settings.launchTime = self.ui.launchTimeEdit.time()

#class that defines window for displaying results in table form
class GSResults(QWidget):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_ResultsWidget()
        self.ui.setupUi(self)
        self.collection = collection

        self.ui.buttonBox.clicked.connect(self.hide)

#class that defines window for displaying documentation of software
class GSDocumentation(QWidget):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_Documentation()
        self.ui.setupUi(self)
        self.collection = collection

#class that defines window for displaying error messages
class GSError(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_ErrorDialog()
        self.ui.setupUi(self)
        self.collection = collection
 
#class that defines control panel window for test mode
class GSControl(QWidget):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_controlPanel()
        self.ui.setupUi(self)
        self.collection = collection

        #Initialize control states
        self.valveControl = 0  # closed
        self.ledState = 0      # False (Off)
        self.servoAngle = 0 # in Â°
        self.dryRunActive = 0 #False
        self.testRunStart = 0 #False (no signal to start test run)
        self.testRunStop = 0 #False (no signal to abort test run)

        #Initialize duration values
        self.valveDelay = QTime(0, 0, 0)
        self.servoDelay = QTime(0, 0, 0)
        self.EOEDelay = QTime(0, 0, 0)

        #Connect signals to slots
        self.connectSignals()
        
    #connect ui buttons to their respective slots
    def connectSignals(self):
        # Valve controls
        self.ui.openValveButton.clicked.connect(self.openValve)
        self.ui.closeValveButton.clicked.connect(self.closeValve)

        # Servo controls
        self.ui.setServoButton.clicked.connect(self.setServoAngle)

        # LED controls
        self.ui.ledOnButton.clicked.connect(self.onLED)
        self.ui.ledOffButton.clicked.connect(self.offLED)

        # Test run controls
        self.ui.startTestButton.clicked.connect(self.startTest)
        self.ui.stopTestButton.clicked.connect(self.stopTest)

        # Dry run control
        self.ui.dryRunOnButton.clicked.connect(self.dryRunSwitch)

        # Reset buttons
        self.ui.valveResetButton.clicked.connect(self.resetValveDelay)
        self.ui.servoResetButton.clicked.connect(self.resetServoDelay)
        self.ui.EOEResetButton.clicked.connect(self.resetEOEDelay)
    
    # external functions for ui controls
    # similar construction for all:
    # set python internal control state
    # create new telecommand frame with function provided by Telecommand class (only if this event should trigger sending a telecommand)
    # update telecommand frame with current control states and durations (only if this event should trigger sending a telecommand)
    # send telecommand frame with function provided by Telecommand class (only if this event should trigger sending a telecommand)

    # Valve control slots
    @Slot()
    def openValve(self):
        self.valveControl = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
    @Slot()
    def closeValve(self):
        self.valveControl = 0
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()

    # Servo control slot
    @Slot()
    def setServoAngle(self):
        self.servoAngle = self.ui.servoValueBox.value()
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()

    # LED control slots
    @Slot()
    def onLED(self):
        self.ledState = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
    @Slot()
    def offLED(self):
        self.ledState = 0
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()

    # Test run control slots
    # special cases, immediately set back to false after sending to avoid starting over again after one run
    @Slot()
    def startTest(self):
        #update delays from input elements before starting test
        self.setDelays()
        self.testRunStart = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
        self.testRunStart = 0
        #starting queue for sending telecommand that start experiment is no longer turned on after sending
        self.collection.telecommand.expStartQueue = True
    @Slot()
    def stopTest(self):
        self.testRunStop = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
        self.testRunStop = 0

    # Dry run control slot
    @Slot()
    def dryRunSwitch(self):
        if self.ui.dryRunOnButton.isChecked():
            self.dryRunActive = 1
        else:
            self.dryRunActive = 0

    # Reset duration slots
    # set all input elements and internal variables to zero
    @Slot()
    def resetValveDelay(self):
        self.ui.valveTimeEdit.setTime(QTime(0, 0, 0))
        self.ui.valveMilliEdit.setText("000")
        self.valveDelay = QTime(0, 0, 0)
    @Slot()
    def resetServoDelay(self):
        self.ui.servoTimeEdit.setTime(QTime(0, 0, 0))
        self.ui.servoMilliEdit.setText("000")
        self.servoDelay = QTime(0, 0, 0)
    @Slot()
    def resetEOEDelay(self):
        self.ui.EOETimeEdit.setTime(QTime(0, 0, 0))
        self.ui.EOEMilliEdit.setText("000")
        self.EOEDelay = QTime(0, 0, 0)

    # internal functions

    # setDelays is called before starting a test run to update internal delay variables from input elements
    def setDelays(self):
        self.valveDelay = self.ui.valveTimeEdit.time().addMSecs(int(self.ui.valveMilliEdit.text()))
        self.servoDelay = self.ui.servoTimeEdit.time().addMSecs(int(self.ui.servoMilliEdit.text()))
        self.EOEDelay = self.ui.EOETimeEdit.time().addMSecs(int(self.ui.EOEMilliEdit.text()))

    # Update the telecommand frame with current control states and durations
    def updateTCFrame(self):
        #times are sent in milliseconds, so convert QTime to milliseconds
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Valve_Delay, (self.valveDelay.minute()*60 + self.valveDelay.second())*1000 + self.valveDelay.msec())
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Servo_Delay, (self.servoDelay.minute()*60 + self.servoDelay.second())*1000 + self.servoDelay.msec())
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.EoE_Delay, (self.EOEDelay.minute()*60 + self.EOEDelay.second())*1000 + self.EOEDelay.msec())
        #PowerOffDelay fehlt
        #NozzleOnDelay fehlt
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Dry_Run, self.dryRunActive)
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.LED_Control, self.ledState)
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Servo_Control, floor(self.servoAngle))
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Valve_Control, self.valveControl)
        #Camera control fehlt
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Test_Abort, self.testRunStop)
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Test_Run, self.testRunStart)

    # clearPanel is called when switching to flight mode to reset all control states and input elements to default values in order to avoid sending unintended data when first opening the control panel in test mode again
    def clearPanel(self):
        self.valveControl = 0
        self.ledState = 0
        self.servoAngle = 0
        self.ui.servoValueBox.setValue(0)
        self.dryRunActive = 0
        self.ui.dryRunOnButton.setChecked(False)
        self.testRunStart = 0
        self.testRunStop = 0
        self.resetValveDelay()
        self.resetServoDelay()
        self.resetEOEDelay()

#class that defines window for connection settings
class GSConnection(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_ConnectionDialog()
        self.ui.setupUi(self)
        self.collection = collection
        # initialize ui elements according to current settings, choose combobox index from currently stored connector setting
        self.ui.ConnectorBox.setCurrentIndex(int(self.collection.settings.connector[-1])-1)

        #connect ui elements to enabling/disabling functions and applySettings function
        self.connect()
    
    #apply settings from ui elements to settings and DataHandling, currently only serial connector settings is functional, tcp not planned
    def applySettings(self):
        if self.ui.RS_Button.isChecked():
            self.collection.settings.connectionType = Settings.SERIAL
            self.collection.settings.connector = self.ui.ConnectorBox.currentText().encode("utf-8")
            DataHandling.SetPort(self.collection.settings.connector)
        else:
            self.collection.settings.connectionType = Settings.TCP

    #connect ui elements to enabling/disabling functions and applySettings function
    def connect(self):
        self.ui.TCP_Button.clicked.connect(self.ui.PortEdit.setEnabled)
        self.ui.TCP_Button.clicked.connect(self.ui.IPEdit.setEnabled)
        self.ui.TCP_Button.clicked.connect(self.ui.ConnectorBox.setDisabled)
        self.ui.RS_Button.clicked.connect(self.ui.PortEdit.setDisabled)
        self.ui.RS_Button.clicked.connect(self.ui.IPEdit.setDisabled)
        self.ui.RS_Button.clicked.connect(self.ui.ConnectorBox.setEnabled)
        self.ui.buttonBox.accepted.connect(self.applySettings)

class GSCalibration(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_Sensor_Calibration()
        self.ui.setupUi(self)
        self.collection = collection

        #initialize variables
        self.selectedSensor = 0 #internal tracking of currently selected sensor from comboBox
        self.selectedEntry = 0 #internal tracking of currently selected calibration point (1,2,3) from radio buttons
        self.currentUnit = "" #unit string for currently selected sensor

        #create calibration point storage lists
        self.analogValues = [[0] * 3 for x in range(DataAccumulation.sensorSize)]
        self.digitalValues = [[0] * 3 for x in range(DataAccumulation.sensorSize)]

        #create exclusive button group for radio buttons
        self.buttonGroup = QButtonGroup(self)
        self.buttonGroup.addButton(self.ui.radioButton1)
        self.buttonGroup.addButton(self.ui.radioButton2)
        self.buttonGroup.addButton(self.ui.radioButton3)
        self.buttonGroup.setExclusive(True)

        #connect clicking of radio buttons and state change of use current digital checkbox to disablingLogic function
        self.ui.radioButton1.clicked.connect(self.disablingLogic)
        self.ui.radioButton2.clicked.connect(self.disablingLogic)
        self.ui.radioButton3.clicked.connect(self.disablingLogic)
        self.ui.useCurrentDigital.stateChanged.connect(self.disablingLogic)

        #click once to ensure proper enabling/disabling of lineEdits at startup
        self.ui.radioButton1.click()

        #connect sensor selection and ok button to their respective functions
        self.ui.sensorSelect.currentIndexChanged.connect(self.selectSensor)
        self.ui.okButton.clicked.connect(self.newCalibrationPoint)
    
    #initialize calibration point storage lists from Calibration Point savefile using DataHandling function
    #is called in late initialization of ClassCollection to ensure DataHandling has been initialized before using its functions
    def initializeCalibrationPoints(self):
        #go through all sensors
        for sensorID, pointSet in enumerate(self.analogValues):

            #go through all calibration points in that sensor
            for pointID, point in enumerate(pointSet):

                #read analog value from dataHandling and save it in storage list
                self.analogValues[sensorID][pointID] = DataHandling.ReadPoint(sensorID, pointID).analog

                #read digital value from dataHandling and save it in storage list
                self.digitalValues[sensorID][pointID] = DataHandling.ReadPoint(sensorID, pointID).digital

        #select first sensor to display its now initialized values at startup
        self.selectSensor()

    #update the displayed sensor value
    def updateValue(self, index: int):
        mappedValue = self.collection.dataAccumulation.sensorData[self.collection.dataAccumulation.gatherIndex][self.selectedSensor]
        self.ui.currentValue.setText(str(mappedValue) + " " + self.currentUnit)
        if self.ui.useCurrentDigital.isChecked():
            match self.selectedEntry:
                case 0:
                    self.ui.digitalEdit1.setText(str(self.collection.dataAccumulation.currentDigitals[self.selectedSensor]))
                case 1:
                    self.ui.digitalEdit2.setText(str(self.collection.dataAccumulation.currentDigitals[self.selectedSensor]))
                case 2:
                    self.ui.digitalEdit3.setText(str(self.collection.dataAccumulation.currentDigitals[self.selectedSensor]))
    
    #select sensor and display currently existing calibration points of this sensor and their units
    @Slot()
    def selectSensor(self):
        #fetch selected sensor index from comboBox
        self.selectedSensor = self.ui.sensorSelect.currentIndex()

        #update lineEdits from local storage lists
        self.ui.analogEdit1.setText(str(self.analogValues[self.selectedSensor][0]))
        self.ui.analogEdit2.setText(str(self.analogValues[self.selectedSensor][1]))
        self.ui.analogEdit3.setText(str(self.analogValues[self.selectedSensor][2]))
        self.ui.digitalEdit1.setText(str(self.digitalValues[self.selectedSensor][0]))
        self.ui.digitalEdit2.setText(str(self.digitalValues[self.selectedSensor][1]))
        self.ui.digitalEdit3.setText(str(self.digitalValues[self.selectedSensor][2]))

        #get unit by checking if selected sensor index is in pressureIndices list from main window
        if self.selectedSensor in self.collection.mainWindow.pressureIndices:
            self.currentUnit = "Pa"
        else:
            self.currentUnit = "K"

        #update unit labels
        self.ui.unitLabel1.setText(self.currentUnit)
        self.ui.unitLabel2.setText(self.currentUnit)
        self.ui.unitLabel3.setText(self.currentUnit)

    #enable lineEdit corresponding to selected radioButton, disable the others
    #if "use current digital" is checked, disable digital lineEdits as well, if not enable the one corresponding to selected radioButton
    @Slot()
    def disablingLogic(self):
        #match case structure to check which radio button is selected
        match self.buttonGroup.checkedButton():
            case self.ui.radioButton1:

                #enable corresponding analog lineEdit, disable others
                self.ui.analogEdit1.setEnabled(True)
                self.ui.analogEdit2.setDisabled(True)
                self.ui.analogEdit3.setDisabled(True)

                #set selectedEntry variable accordingly
                self.selectedEntry = 0

                #if "use current digital" is not checked, enable corresponding digital lineEdit, disable others, if not checked disable all digital lineEdits
                if not self.ui.useCurrentDigital.isChecked():
                    self.ui.digitalEdit1.setEnabled(True)
                else:
                    self.ui.digitalEdit1.setDisabled(True)
                self.ui.digitalEdit2.setDisabled(True)
                self.ui.digitalEdit3.setDisabled(True)

            #radioButton2 case equivalent to radioButton1
            case self.ui.radioButton2:
                self.ui.analogEdit1.setDisabled(True)
                self.ui.analogEdit2.setEnabled(True)
                self.ui.analogEdit3.setDisabled(True)
                self.selectedEntry = 1
                self.ui.digitalEdit1.setDisabled(True)
                if not self.ui.useCurrentDigital.isChecked():
                    self.ui.digitalEdit2.setEnabled(True)
                else:
                    self.ui.digitalEdit2.setDisabled(True)
                self.ui.digitalEdit3.setDisabled(True)

            #radioButton3 case equivalent to radioButton1
            case self.ui.radioButton3:
                self.ui.analogEdit1.setDisabled(True)
                self.ui.analogEdit2.setDisabled(True)
                self.ui.analogEdit3.setEnabled(True)
                self.selectedEntry = 2
                self.ui.digitalEdit1.setDisabled(True)
                self.ui.digitalEdit2.setDisabled(True)
                if not self.ui.useCurrentDigital.isChecked():
                    self.ui.digitalEdit3.setEnabled(True)
                else:
                    self.ui.digitalEdit3.setDisabled(True)

        #if "use current digital" is checked, the selected sensor will show current digital value in the corresponding digital lineEdit, so call selectSensor for the case that it is now unchecked and the set digital value needs to be updated
        if not self.ui.useCurrentDigital.isChecked():
            self.selectSensor()
    
    #save the currently selected calibration point
    @Slot()
    def newCalibrationPoint(self):
        #initialize temporary variables
        analogValue = 0
        digitalValue = 0

        #fetch analog value from corresponding lineEdit according to selectedEntry and convert string to float
        match self.selectedEntry:
            case 0:
                analogValue = float(self.ui.analogEdit1.text())
            case 1:
                analogValue = float(self.ui.analogEdit2.text())
            case 2:
                analogValue = float(self.ui.analogEdit3.text())

        #save analog value in local storage list
        self.analogValues[self.selectedSensor][self.selectedEntry] = analogValue

        #if use currentDigital is not checked, fetch digital value from corresponding lineEdit according to selectedEntry and convert string to int
        if not self.ui.useCurrentDigital.isChecked():
            match self.selectedEntry:
                case 0:
                    digitalValue = int(self.ui.digitalEdit1.text())
                case 1:
                    digitalValue = int(self.ui.digitalEdit2.text())
                case 2:
                    digitalValue = int(self.ui.digitalEdit3.text())

        #if use currentDigital is checked, fetch current digital value from DataAccumulation
        else:
            digitalValue = self.collection.dataAccumulation.sensorData[self.collection.dataAccumulation.gatherIndex][self.selectedSensor]

        #save digital value in local storage list
        self.digitalValues[self.selectedSensor][self.selectedEntry] = digitalValue

        #write calibration point with determined values to Calibration Point savefile using DataHandling function
        DataHandling.WritePoint(self.selectedSensor, self.selectedEntry, digitalValue, analogValue)

        #reselect sensor to update displayed values
        self.selectSensor()

    #update displayed current sensor value when new frame is available
    @Slot(int)
    def onNewFrame(self, index:int):
        self.updateValue(index)

class GSDiagramSettings(QWidget):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_diagramSettings()
        self.ui.setupUi(self)
        self.collection = collection
        self.connect()
    
    @Slot()
    def applySettings(self):
        #variable to track if made changes in diagram settings require a complete plot rebuild, False by default
        plotRebuildNecessary = False

        #axis settings, no plot rebuild necessary here as changes will be applied in updateAxes function
        #check if self -scaling is checked, if so, set stored settings accordingly
        if self.ui.pressureSelfScaling.isChecked():
            self.collection.settings.pressureAxeMode = Settings.SELFSCALING
        else:
            #if not, save settings accordingly and fetch fixed axis max-value from lineEdit
            self.collection.settings.pressureAxeMode = Settings.FIXEDVALUE
            self.collection.settings.pressureAxeValue = float(self.ui.pressureLineEdit.text())

        #temperature axis settings equivalent to pressure axis settings
        if self.ui.temperatureSelfScaling.isChecked():
            self.collection.settings.temperatureAxeMode = Settings.SELFSCALING
        else:
            self.collection.settings.temperatureAxeMode = Settings.FIXEDVALUE
            self.collection.settings.temperatureAxeValue = float(self.ui.temperatureLineEdit.text())

        #time span mode settings
        #check if scrolling mode is checked
        if self.ui.scrollingRadioButton.isChecked():

            #if mode was not already in scrolling, set it and mark plot rebuild as necessary
            if self.collection.settings.timespanMode != Settings.SCROLLING:
                plotRebuildNecessary = True
                self.collection.settings.timespanMode = Settings.SCROLLING

            #check if scrolling time has changed, if so, set it and mark plot rebuild as necessary
            if self.collection.settings.scrollingTimeSeconds != int(self.ui.scrollingTimeEdit.time().minute()*60 + self.ui.scrollingTimeEdit.time().second()):
                plotRebuildNecessary = True
                self.collection.settings.scrollingTimeSeconds = int(self.ui.scrollingTimeEdit.time().minute()*60 + self.ui.scrollingTimeEdit.time().second())

            #if both arent True, scrolling mode is activated but no changes were made -> no action necessary

        #if expanding mode is checked
        else:
            #if mode was not already in expanding, set it and mark plot rebuild as necessary
            if self.collection.settings.timespanMode != Settings.EXPANDING:
                plotRebuildNecessary = True
                self.collection.settings.timespanMode = Settings.EXPANDING

            #check if expandFrom value has changed, if so, set it and mark plot rebuild as necessary
            if self.collection.settings.expandFrom != self.ui.firstShownComboBox.currentIndex():
                plotRebuildNecessary = True
                self.collection.settings.expandFrom = self.ui.firstShownComboBox.currentIndex()
        
        #if a plot rebuild is necessary, set rebuildPlot flag in plotWorker and start the worker thread
        if plotRebuildNecessary:
            self.collection.plotWorker.rebuildPlot = True
            self.collection.plotWorker.start()

        #update axes for potential changes in axis settings
        self.collection.mainWindow.updateAxes()

    #enabling/disabling logic for lineEdits according to selected radio buttons
    @Slot()
    def radioButtonClicked(self):
        #lineEdits only enabled if self-scaling is not checked
        if self.ui.pressureSelfScaling.isChecked():
            self.ui.pressureLineEdit.setDisabled(True)
        else:
            self.ui.pressureLineEdit.setEnabled(True)
        if self.ui.temperatureSelfScaling.isChecked():
            self.ui.temperatureLineEdit.setDisabled(True)
        else:
            self.ui.temperatureLineEdit.setEnabled(True)

        #starting point combo box for expanding mode only enabled if scrolling mode is not checked
        if self.ui.scrollingRadioButton.isChecked():
            self.ui.scrollingTimeEdit.setEnabled(True)
            self.ui.firstShownComboBox.setDisabled(True)
        else:
            self.ui.scrollingTimeEdit.setDisabled(True)
            self.ui.firstShownComboBox.setEnabled(True)

    #connect signals to slots
    def connect(self):
        self.ui.pressureSelfScaling.clicked.connect(self.radioButtonClicked)
        self.ui.pressureFixedValue.clicked.connect(self.radioButtonClicked)
        self.ui.temperatureSelfScaling.clicked.connect(self.radioButtonClicked)
        self.ui.temperatureFixedValue.clicked.connect(self.radioButtonClicked)
        self.ui.scrollingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.scrollingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.expandingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.expandingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.applyDiagramSettings.clicked.connect(self.applySettings)

#class for accumulating incoming data frames and sorting them into numpy arrays
class DataAccumulation(QObject):
    #signal emitted when a new frame has been processed, sends the index of the new data point in the arrays to interested slots
    newFrameSignal = Signal(int)
    statusDisplaySignal = Signal(int)
    setConnectionStatusSignal = Signal(int)

    #class variables for amount of sensors and household entries
    sensorSize = 13
    householdSize = 29

    #max digital values of 24-bit and 16-bit sensors for checking invalid data
    MAX24 = (1<<24)-1
    MAX16 = (1<<16)-1

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.collection = collection

        #initialize variables
        self.gatherIndex = -1 #index of the last data point in the arrays (point with highest system time). -1 by default
        self.newIndex = -1 #index of the newly added data point to the arrays. -1 by default
        self.liftOffIndex = -1 #index of the data point corresponding to launch time. -1 by default
        self.startOfExperimentIndex = -1 #index of the data point corresponding to start of experiment. -1 by default
        self.noPacketCount = 0 #counter for number of consecutive empty frames received, used for connection status tracking
        self.allocationSize = 5000 #number of data points to allocate space for in each extension of the arrays

        #initialize data arrays with initial allocation size
        self.sensorData = np.ones((self.allocationSize, self.sensorSize))
        self.household = np.ones((self.allocationSize, self.householdSize))

        #initialize current digitals array. Used for calibration window to get current digital values of sensors, since sensorData only contains mapped analog values
        self.currentDigitals = [1] * self.sensorSize

    def accumulate(self):
        #switch for testing purposes
        testData = False

        #Get Frame and check connection status
        if not testData:
            #make status display red if port is open, purple is port is not open, overrided by frame flags later if packet can be received
            if DataHandling.PortIsOpen():
                self.setConnectionStatusSignal.emit(GSMain.INACTIVE)
            else:
                self.setConnectionStatusSignal.emit(GSMain.NOCONNECTION)

        #while true loop to process multiple conecutive frames, as long as they are available. empty frame will break the loop
        while True:
            if not testData:

                #fetch frame from DataHandling
                frame = DataHandling.GetNextFrame()

                #check if frame is empty
                if DataHandling.FrameIsEmpty(frame):

                    #increase no packet counter
                    self.noPacketCount += 1

                    #if 20 consecutive empty frames have been received, emit status display signal to update connection status in main window and reset no packet counter
                    if self.noPacketCount >= 20:
                        self.statusDisplaySignal.emit(self.gatherIndex)
                        self.noPacketCount = 0

                    #break from loop
                    break

                #check if frame has OK flag (crc and checksum correct)
                if DataHandling.FrameHasFlag(frame, Flag.OK):

                    #make connection status display green
                    self.setConnectionStatusSignal.emit(GSMain.ACTIVE)

                    #reset no packet counter
                    self.noPacketCount = 0

                    #increase gather index for new data point
                    self.gatherIndex += 1

                    #dont break from loop, continue


                else:
                    #make connection status display yellow, because frame has errors
                    self.setConnectionStatusSignal.emit(GSMain.ISSUES)

                    #update status display in main window
                    self.statusDisplaySignal.emit(self.gatherIndex)

                    #reset no packet counter
                    self.noPacketCount = 0

                    #try to continue to next frame without increasing gather index or entering any of the data into arrays
                    continue

            else:
                ###
                self.gatherIndex += 1 ###only for testing purposes###
                ###

            #extend arrays if necessary
            if self.gatherIndex%self.allocationSize == 0 and self.gatherIndex != 0:

                #create extensions of arrays with allocation size
                dataExtension = np.ones((self.allocationSize, self.sensorSize))
                householdExtension = np.ones((self.allocationSize, self.householdSize))

                #concatenate extensions to existing arrays
                self.sensorData = np.concatenate((self.sensorData, dataExtension))
                self.household = np.concatenate((self.household, householdExtension))

            if not testData:
                #if array has no entries yet, or system time of new frame is higher than the last entry in array, new index is simply gather index
                if self.gatherIndex <= 0 or DataHandling.ReadFrame(frame, TMID.System_Time) > self.household[self.gatherIndex-1][PyID.System_Time]:
                    self.newIndex = self.gatherIndex

                #in other case, find correct index for new data point by searching sorted system time array
                else:
                    self.newIndex = np.searchsorted(self.household[:self.gatherIndex, PyID.System_Time], DataHandling.ReadFrame(frame, TMID.System_Time))

            else:
                ###
                self.newIndex = self.gatherIndex ###only for testing purposes###
                ###

            #go through all sensors and read their values from frame, map them and store them in sensorData array at newIndex
            for i in range(self.sensorSize):

                if testData:
                    ###
                    self.sensorData[self.newIndex][i] = int(150*sin(radians((10*self.gatherIndex)%360 + 10*i))+150) ###only for testing purposes###
                    ###

                else:
                    #store mapped sensor value in sensorData array
                    self.sensorData[self.newIndex][i] = DataHandling.MapSensorValue(i, DataHandling.ReadFrame(frame, i))

                    #store unmapped digital value in currentDigitals array for calibration window
                    self.currentDigitals[i] = DataHandling.ReadFrame(frame, i)

            if not testData:
                #special case for accumulator pressure, override it as sum of itself and ambient pressure, as it is a relative pressure sensor
                self.sensorData[self.newIndex][PyID.Accumulator_Pressure] = self.sensorData[self.newIndex][PyID.Accumulator_Pressure] + self.sensorData[self.newIndex][PyID.Ambient_Pressure]

            if testData:
                ###
                self.household[self.newIndex][PyID.System_Time] = 1000/self.collection.dataHandlingThread.frequency*self.gatherIndex  ###only for testing purposes###
                ###

                self.newFrameSignal.emit(int(self.newIndex))
                self.statusDisplaySignal.emit(self.gatherIndex)

                break

            else:
                #check health of all sensors by checking their values for plausability
                for i in range(self.sensorSize):

                    #fetch current and last value of sensor
                    currentVal = self.sensorData[self.gatherIndex][i]
                    lastVal = self.sensorData[self.gatherIndex-1][i]

                    #check if current value hasnt changed (not plausible) -> mark as ISSUES (yellow)
                    if currentVal == lastVal:
                        self.household[self.newIndex][i] = GSMain.ISSUES

                    #in other case, mark as ACTIVE (green)
                    else:
                        self.household[self.newIndex][i] = GSMain.ACTIVE

                    #check if sensor is ambient pressure sensor or accumulator pressure sensor as they are the only 24-bit sensors
                    if i == PyID.Ambient_Pressure or i == PyID.Accumulator_Pressure:

                        #if current value is either max 24-bit value or 0, mark as INACTIVE (red)
                        if currentVal == self.MAX24 or currentVal == 0:
                            self.household[self.newIndex][i] = GSMain.INACTIVE

                    #in other case, for 16-bit sensors
                    else:

                        #if current value is either max 16-bit value or 0, mark as INACTIVE (red)
                        if currentVal == self.MAX16 or currentVal == 0:
                            self.household[self.newIndex][i] = GSMain.INACTIVE

                #go through all household entries, read their values from frame and store them in household array at newIndex
                self.household[self.newIndex][PyID.Nozzle_Open] = DataHandling.ReadFrame(frame, TMID.Nozzle_Open)
                self.household[self.newIndex][PyID.Nozzle_Closed] = DataHandling.ReadFrame(frame, TMID.Nozzle_Closed)
                self.household[self.newIndex][PyID.Nozzle_Servo] = DataHandling.ReadFrame(frame, TMID.Nozzle_Servo)
                self.household[self.newIndex][PyID.Reservoir_Valve] = DataHandling.ReadFrame(frame, TMID.Reservoir_Valve)
                self.household[self.newIndex][PyID.LEDs] = DataHandling.ReadFrame(frame, TMID.LEDs)
                self.household[self.newIndex][PyID.Sensorboard_P] = DataHandling.ReadFrame(frame, TMID.Sensorboard_P)
                self.household[self.newIndex][PyID.Sensorboard_T] = DataHandling.ReadFrame(frame, TMID.Sensorboard_T)
                self.household[self.newIndex][PyID.Mainboard_T] = DataHandling.ReadFrame(frame, TMID.Mainboard_T)
                self.household[self.newIndex][PyID.Mainboard_V] = DataHandling.ReadFrame(frame, TMID.Mainboard_V)
                self.household[self.newIndex][PyID.System_Time] = DataHandling.ReadFrame(frame, TMID.System_Time)
                self.household[self.newIndex][PyID.Lift_Off] = DataHandling.ReadFrame(frame, TMID.Lift_Off)
                self.household[self.newIndex][PyID.Start_Experiment] = DataHandling.ReadFrame(frame, TMID.Start_Experiment)
                self.household[self.newIndex][PyID.End_Experiment] = DataHandling.ReadFrame(frame, TMID.End_Experiment)
                self.household[self.newIndex][PyID.Mode] = DataHandling.ReadFrame(frame, TMID.Mode)
                self.household[self.newIndex][PyID.Experiment_State] = DataHandling.ReadFrame(frame, TMID.Experiment_State)

                #if gatherIndex is not 0, check for rising edges of lift off and start of experiment values to store their indices in settings
                if self.gatherIndex > 0:
                    if self.household[self.gatherIndex - 1][PyID.Lift_Off] == 0 and self.household[self.gatherIndex][PyID.Lift_Off] == 1:
                        self.liftOffIndex = self.gatherIndex
                    if self.household[self.gatherIndex -1][PyID.Start_Experiment] == 0 and self.household[self.gatherIndex][PyID.Start_Experiment] == 1:
                        self.startOfExperimentIndex = self.gatherIndex

            #emit new frame signal for graph and calibration window updates
            self.newFrameSignal.emit(int(self.newIndex))

            #emit status display signal
            self.statusDisplaySignal.emit(self.gatherIndex)

            if testData:
                ###
                break ###only for testing purposes###
                ###

#enum class for keeping track of python internal indexing of sensors and household entries
class PyID(IntEnum):
    Ambient_Pressure = 0
    Compare_Temperature = 1
    Accumulator_Pressure = 2
    Accumulator_Temperature = 3
    Chamber_Pressure = 4
    Chamber_Temperature_1 = 5
    Chamber_Temperature_2 = 6
    Nozzle_1_Pressure = 7
    Nozzle_1_Temperature = 8
    Nozzle_2_Pressure = 9
    Nozzle_2_Temperature = 10
    Nozzle_3_Pressure = 11
    Nozzle_3_Temperature = 12
    Nozzle_Open = 13
    Nozzle_Closed = 14
    Nozzle_Servo = 15
    Reservoir_Valve = 16
    LEDs = 17
    Sensorboard_P = 18
    Sensorboard_T = 19
    Mainboard = 20
    Mainboard_T = 21
    Mainboard_V = 22
    System_Time = 23
    Lift_Off = 24
    Start_Experiment = 25
    End_Experiment = 26
    Mode = 27
    Experiment_State = 28


class PlotWorker(QThread):
    replaceSeriesSignal = Signal(int, list)
    clearSeriesSignal = Signal(int)
    updatePlotMetricsSignal = Signal(int, float, float)

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.collection = collection

        #type of plot work to be done, can be set from other threads
        self.rebuildPlot = False
        self.reduceArray = False

    #override run function of QThread, is triggered when thread is started from other threads
    def run(self):
        #check which type of work to do
        if self.rebuildPlot:
            self.doRebuildPlot()
        if self.reduceArray:
            self.doReduceArray()

    def doRebuildPlot(self):
        #fetch necessary data
        settings = self.collection.settings
        dataAcc = self.collection.dataAccumulation
        sensorData = dataAcc.sensorData
        household = dataAcc.household
        mainWindow = self.collection.mainWindow

        #variable to track if plot should be cleared instead of rebuilt
        clear = False

        #determine start and end indices for plot data according to settings
        #start Index 0 by default
        startIndex = 0

        #endIndex should always be gatherIndex (newest index after system time)
        endIndex = dataAcc.gatherIndex

        #start index determination for expaning mode
        if settings.timespanMode == Settings.EXPANDING:
            match settings.expandFrom:
                case Settings.LO:
                    #if liftOffIndex is set, use it as start index, else clear plot, no data should be shown until lift off
                    if dataAcc.liftOffIndex != -1:
                        startIndex = dataAcc.liftOffIndex
                    else:
                        clear = True

                #start index determination for start of experiment same as lift off
                case Settings.SOE:
                    if dataAcc.startOfExperimentIndex != -1:
                        startIndex = dataAcc.startOfExperimentIndex
                    else:
                        clear = True

        #start index determination for scrolling mode
        else:
            #start index is either as many indices from gatherIndex, as fit into scrolling time, or 0 if not enough data points yet
            startIndex = max(0, dataAcc.gatherIndex - (self.collection.dataHandlingThread.frequency * settings.scrollingTimeSeconds))

        #check if endIndex is lower or equal to startIndex, if so, clear plot, should not happen due to previous checks, but just in case
        if endIndex <= startIndex:
            clear = True

        #clear plot if demanded
        if clear:
            for i in range(self.collection.mainWindow.sensorSize):
                self.clearSeriesSignal.emit(i)
            return
        
        #if startIndex is 0, relevant data can be sliced from full array directly
        if startIndex == 0:
            xValues = household[:endIndex, PyID.System_Time]
            yMatrix = sensorData[:endIndex, :DataAccumulation.sensorSize]

        #for arbitrary startIndex, slicing needs to be done with ascontiguousarray
        else:
            xValues = np.ascontiguousarray(household[startIndex:endIndex, PyID.System_Time])
            yMatrix = np.ascontiguousarray(sensorData[startIndex:endIndex, :DataAccumulation.sensorSize])

        #for every sensor, create list of QPointF from x and y values and replace time series data in main window
        for i in range(DataAccumulation.sensorSize):
            #get y values of this sensor from previously sliced yMatrix
            yValues =  yMatrix[:, i]

            #create list of QPointF from x and y values
            points = [QPointF(x, y) for x, y in zip(xValues, yValues)]

            #replace time series data in main window
            self.replaceSeriesSignal.emit(i, points)

        #update main window variables for highest pressure, highest temperature and currently newest global Index
        self.updatePlotMetricsSignal.emit(dataAcc.gatherIndex, np.max(yMatrix[startIndex:endIndex, self.collection.mainWindow.pressureIndices]), np.max(yMatrix[startIndex:endIndex, self.collection.mainWindow.temperatureIndices]))

        #self.collection.mainWindow.repaintPlots()

        #reset rebuildPlot flag
        self.rebuildPlot = False

    #functionalilty to reduce amount of displayed point not implemented yet
    def doReduceArray(self):
        self.reduceArray = False
        pass

#class that hosts the DataHandling loop in a separate thread
class DataHandlingThread(QThread):
    sendStepSignal = Signal()

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.collection = collection

        #frequency of DataHandling loop in Hz
        self.frequency = 20

    #override run function of QThread, is triggered from constructor of ClassCollection
    def run(self):
        #calculate period in milliseconds from frequency
        period_ms = 1000 / self.frequency

        i = 0 ###only for debugging
        times = [0]*50 ###only for debugging

        #initialize DataHandling
        DataHandling.Initialize()

        #main loop
        while True:
            #get starting time of loop iteration
            clock = time.monotonic_ns()

            DataHandling.DebugLastFrame()####only for debugging

            #make all updates in DataHandling
            DataHandling.UpdateAll()

            # clock2 = time.monotonic_ns()
            # print("DataHandlingUpdate-time: " + str((clock2-clock)/1000000))

            #accumulate and sort incoming data frames into python local numpy arrays
            self.collection.dataAccumulation.accumulate()

            # clock3 = time.monotonic_ns()
            # print("dataAcc-time: " + str((clock3-clock2)/1000000))

            #send telecommand step
            self.sendStepSignal.emit()

            # clock4 = time.monotonic_ns()
            # print("tc-time: " + str((clock4-clock3)/1000000))
            # clock5 = time.monotonic_ns()
            # print("signal-emit-time: " + str((clock5-clock4)/1000000))

            #cleanly exit thread if interruption is requested
            if self.isInterruptionRequested():
                DataHandling.CloseAll()
                break

            #get end time of loop iteration
            endTime = time.monotonic_ns()

            # print(period_ms-(endTime - clock)/1000000)

            #sleep for remaining period time if loop iteration was faster than period
            if (endTime - clock)/1000000 < period_ms:
                time.sleep((period_ms - (endTime - clock) / 1000000)/1000)

            clock6 = time.monotonic_ns() ####only for debugging
            # print("rest-time: " + str((clock6-clock5)/1000000))

            #debugging loop time measurement
            times[i] = (clock6-clock)/1000000
            i += 1
            if i == 50:
                average = 0
                for timeVal in times:
                    average += timeVal
                average = average/50
                print("DataHandling Loop-time average: " + str(average) + " with " + str(self.collection.dataAccumulation.gatherIndex + 1) + " points\n")
                i = 0

#class that collects all instantiated classes and connects them as necessary
#other classes only need to have access to this class to access other classes
class ClassCollection:
    def __init__(self):
        self.settings = Settings()
        self.telecommand = Telecommand(self)
        self.dataAccumulation = DataAccumulation(self)
        self.mainWindow = GSMain(self)
        self.startWindow = GSStart(self)
        self.controlPanel = GSControl(self)
        self.timeWindow = GSLaunchTime(self)
        self.documentationWindow = GSDocumentation(self)
        self.errorWindow = GSError(self)
        self.resultsWindow = GSResults(self)
        self.connectionWindow = GSConnection(self)
        self.calibrationWindow = GSCalibration(self)
        self.plotWorker = PlotWorker(self)
        self.diagramSettingsWindow = GSDiagramSettings(self)

        #connect onNewFrame signals
        self.dataAccumulation.newFrameSignal.connect(self.mainWindow.onNewFrame)
        self.dataAccumulation.newFrameSignal.connect(self.calibrationWindow.onNewFrame)

        #connect statusDisplaySignal and setConnectionStatusSignal
        self.dataAccumulation.statusDisplaySignal.connect(self.mainWindow.displayStatus)
        self.dataAccumulation.setConnectionStatusSignal.connect(self.mainWindow.setConnectionStatus)

        #connect replace plot signal, clear plot signal and updatePlotMetricsSignal from plotWorker
        self.plotWorker.replaceSeriesSignal.connect(self.mainWindow.replaceSeries)
        self.plotWorker.clearSeriesSignal.connect(self.mainWindow.clearSeries)
        self.plotWorker.updatePlotMetricsSignal.connect(self.mainWindow.updatePlotMetrics)

        #DataHandling setup
        self.dataHandlingThread = DataHandlingThread(self)

        #Signal for sending telecommand step from DataHandling thread to Telecommand class
        self.dataHandlingThread.sendStepSignal.connect(self.telecommand.sendStep)

        #Start DataHandling loop
        self.dataHandlingThread.start()

        #lateInit for events that need DataHandling to be running
        self.mainWindow.connect()
        time.sleep(0.1)  #ensure DataHandling is initialized before CalibrationWindow tries to read points
        self.calibrationWindow.initializeCalibrationPoints()

    #inter-window connections
    def interWindowConnection(self):
        self.mainWindow.ui.actionRestart.triggered.connect(self.startWindow.show)
        self.mainWindow.ui.actionRestart.triggered.connect(self.mainWindow.hide)
        self.mainWindow.ui.actionControl_Panel.triggered.connect(self.controlPanel.show)
        self.mainWindow.ui.actionDocumentation.triggered.connect(self.documentationWindow.show)
        self.mainWindow.ui.actionConnect.triggered.connect(self.connectionWindow.show)
        self.mainWindow.ui.actionResults.triggered.connect(self.resultsWindow.show)
        self.mainWindow.ui.actionEstimated_Launch_Time.triggered.connect(self.timeWindow.show)
        self.startWindow.accepted.connect(self.mainWindow.applySettings)
        self.startWindow.accepted.connect(self.mainWindow.show)
        self.timeWindow.accepted.connect(self.mainWindow.applySettings)
        self.mainWindow.ui.actionCalibration.triggered.connect(self.calibrationWindow.show)
        self.mainWindow.ui.actionDiagrams.triggered.connect(self.diagramSettingsWindow.show)

    #shutdown procedure to stop DataHandling thread cleanly
    def shutdown(self):
        #request interruption of DataHandling thread, thread is running to the point at which it reacts to the interruption request and closes
        thread = self.dataHandlingThread
        thread.requestInterruption()

        #get QApplication instance
        app = QApplication.instance()

        #initialize timeout variables
        timeout_ms = 5000
        interval_ms = 50
        waited = 0

        #process events and wait until thread has stopped or timeout is reached
        while thread.isRunning() and waited < timeout_ms:
            app.processEvents()
            time.sleep(interval_ms/1000)
            waited += interval_ms

        #finally quit application
        app.quit()

#Main program
if __name__ == "__main__":
    #initialize QApplication
    GS = QApplication()

    #initialize application icon
    icon = QIcon("Ressources\\meega_logo_small.ico")
    GS.setWindowIcon(icon)

    #initialize translator and set default locale to C
    translator = QTranslator()
    QLocale.setDefault(QLocale.C)

    #initialize class collection, which in turn initializes all other classes
    collection = ClassCollection()

    #install translator according to selected locale in settings
    if translator.load(collection.settings.locale, "MEEGA_Language"):
        GS.installTranslator(translator)

    #perform inter-window connections
    collection.interWindowConnection()
    
    #showing the startup screen
    collection.startWindow.show()

    #starting the PyQt Application Loop (everything has to be defined prior to this)
    sys.exit(GS.exec())
#End