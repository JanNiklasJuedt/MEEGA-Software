#imports
#miscellaneous imports
from __future__ import annotations #for forward type references
from enum import IntEnum
from math import floor
from math import sin, radians
import numpy as np
import sys
import time
import winreg
from winsdk.windows.ui.viewmanagement import UISettings, UIColorType
import csv
import os

#import of qt modules
from PySide6.QtGui import (QAction, QActionGroup, QIcon, QImage, QPixmap, QPainter, QPen, QColor, QBrush, QPalette)
from PySide6.QtWidgets import (QApplication, QButtonGroup, QMainWindow, QDialog, QWidget, QVBoxLayout, QStyleFactory, QProgressBar, QFileDialog)
from PySide6.QtCore import (QFile, Signal, Slot, QTranslator, QLocale, QThread, QPointF, QObject, QTimeZone)
from PySide6.QtCharts import (QChart, QChartView, QLineSeries, QValueAxis)
from PySide6.QtSvg import QSvgRenderer

#imports from autogenerated ui-files
from MEEGA_mainWindow import *
from MEEGA_calibration import *
from MEEGA_startup import *
from MEEGA_Connection import *
from MEEGA_time import *
from MEEGA_documentation import *
from MEEGA_error import *
from MEEGA_controlPanel import *
from MEEGA_results import *
from MEEGA_calibration import *
from MEEGA_diagramSettings import *
from MEEGA_export import *
from MEEGA_liveValuesWidget import *
import resources_rc

#import from own data handling module with c functions
from MEEGA_PyDataHandling import *

#class to handle program settings
#keep track of diagram settings, program settings
class Settings:
    FLIGHT = 1
    TEST = 0
    #diagram flags
    SELFSCALING = 0
    FIXEDVALUE = 1
    SCROLLING = 0
    EXPANDING = 1
    ALL = 0
    LO = 1
    SOE = 2
    defaultFilePath = "Default.meega"
    defaultCalibrationPath = "MEEGA_Calibration.txt"
    defaultLaunchTime = QDateTime(QDate.currentDate(), QTime(12,0,0), QTimeZone(b"Europe/Berlin"))

    def __init__(self, locale: QLocale = None):
        if locale == None:
            self.locale = QLocale()
        else:
            self.locale = QLocale(locale)
        self.mode = self.TEST
        self.connector = "COM4"
        self.filePath = self.defaultFilePath
        self.calibrationPath = self.defaultCalibrationPath
        self.estimatedLaunchTime = self.defaultLaunchTime
        self.pressureAxeMode = self.SELFSCALING
        self.temperatureAxeMode = self.SELFSCALING
        self.timespanMode = self.EXPANDING
        self.pressureAxeValue = 300
        self.temperatureAxeValue = 300
        self.scrollingTimeSeconds = 10
        self.expandFrom = self.ALL
        self.maxPlotPoints = 1002 #number divisible by 3 to simplify point reduction in plot worker
        self.timeZone = QTimeZone(b"Europe/Berlin")
        self.powerOnTime = None
        self.LOTime = None
        self.SOETime = None
        self.nozzleOpenTime = None
        self.EOETime = None
        self.LOtoExpPrepSecs = 70
        self.ExpPreptoSOESecs = 10
        self.SOEtoNozzleOpenSecs = 27
        self.nozzleOpenToEOESecs = 30

    @Slot(QDateTime)
    def setPowerOnTime(self, time: QDateTime):
        self.powerOnTime = time

    @Slot(QDateTime)
    def setLOTime(self, time: QDateTime):
        self.LOTime = time

    @Slot(QDateTime)
    def setSOETime(self, time: QDateTime):
        self.SOETime = time

    @Slot(QDateTime)
    def setNozzleOpenTime(self, time: QDateTime):
        self.nozzleOpenTime = time

    @Slot(QDateTime)
    def setEOETime(self, time: QDateTime):
        self.EOETime = time

#class to handle telecommands
class Telecommand(QObject):
    def __init__(self, collection):
        self.collection = collection
        self.sendCounter = 0
        self.expStartQueue = False #variable to queue another telecommand to deactivate experiment start after experiment start has been sent, is being set True in control panel after experiment start sendInit() is called

    #creating Telecommand in DataHandling, writing program mode (test/flight))
    def newTCFrame(self):
        self.tcframe = DataHandling.CreateTC()
        DataHandling.WriteFrame(self.tcframe, TCID.Mode_Change, self.collection.settings.mode)

    #initialize sending of 10 identical telecommands to ensure reception
    def sendInit(self):
        self.expStartQueue = False #reset to standard False, as sending dedicated turn off telecommands is unnecessary if one with additional changes is sent anyways
        self.sendCounter = 10

    #single sending step called by DataHandlingThread
    @Slot()
    def sendStep(self):
        if self.sendCounter > 0:
            DataHandling.AddFrame(self.tcframe)
            self.sendCounter -= 1
        #sending turn off of start signal if queued
        elif self.expStartQueue:
            self.newTCFrame()
            self.collection.controlPanel.updateTCFrame()
            self.sendInit()

#enum class for keeping track of python internal indexing of sensors and household entries
class PyID(IntEnum):
    Ambient_Pressure = 0
    Compare_Temperature = 1
    Accumulator_Pressure = 2
    Accumulator_Temperature = 3
    Chamber_Pressure = 4
    Chamber_Temperature_1 = 5
    Chamber_Temperature_2 = 6
    Nozzle_1_Pressure = 7
    Nozzle_1_Temperature = 8
    Nozzle_2_Pressure = 9
    Nozzle_2_Temperature = 10
    Nozzle_3_Pressure = 11
    Nozzle_3_Temperature = 12
    Nozzle_Open = 13
    Nozzle_Closed = 14
    Nozzle_Servo = 15
    Reservoir_Valve = 16
    LEDs = 17
    Sensorboard_P = 18
    Sensorboard_T = 19
    Mainboard = 20
    Mainboard_T = 21
    Mainboard_V = 22
    System_Time = 23
    Lift_Off = 24
    Start_Experiment = 25
    End_Experiment = 26
    Mode = 27
    Experiment_State = 28

#class to define the Main Window
class GSMain(QMainWindow):
    doTaskSignal = Signal(int)

    #Flags for status display
    ACTIVE = 1
    ISSUES = 2
    ISSUESSTM = 3
    INACTIVE = 0
    NOCONNECTION = 3
    def __init__(self, collection: ClassCollection):
        super().__init__()

        #importing visuals from the ui-file
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        #settings margins, so that contents dont cover edges
        treeWidgetLayout = self.ui.SensorSelectionGroupBox.layout()
        treeWidgetLayout.addWidget(self.ui.treeWidget)
        treeWidgetLayout.setContentsMargins(2, 5, 2, 2)

        #creating variables
        self.connectionStatus = self.NOCONNECTION
        self.collection = collection

        #creating local list of status display labels from ui files
        #not using PyID because not all householding data have a status display
        self.statusDisplay = [None]*21
        self.statusDisplay[0] = self.ui.statusLabelPAmbient
        self.statusDisplay[1] = self.ui.statusLabelTCompare
        self.statusDisplay[2] = self.ui.statusLabelPAccumulator
        self.statusDisplay[3] = self.ui.statusLabelTAccumulator
        self.statusDisplay[4] = self.ui.statusLabelPChamber
        self.statusDisplay[5] = self.ui.statusLabelTChamber2
        self.statusDisplay[6] = self.ui.statusLabelPNozzle1
        self.statusDisplay[7] = self.ui.statusLabelTNozzle1
        self.statusDisplay[8] = self.ui.statusLabelPNozzle2
        self.statusDisplay[9] = self.ui.statusLabelTNozzle2
        self.statusDisplay[10] = self.ui.statusLabelPNozzle3
        self.statusDisplay[11] = self.ui.statusLabelTNozzle3
        self.statusDisplay[12] = self.ui.statusLabelServo
        self.statusDisplay[13] = self.ui.statusLabelValve
        self.statusDisplay[14] = self.ui.statusLabelLED
        self.statusDisplay[15] = self.ui.statusLabelPChip
        self.statusDisplay[16] = self.ui.statusLabelTChip
        self.statusDisplay[17] = self.ui.statusLabelMainboardT
        self.statusDisplay[18] = self.ui.statusLabelMainboardV
        self.statusDisplay[19] = self.ui.statusLabelLiftOff
        self.statusDisplay[20] = self.ui.statusLabelSOE

        #creating status pixmaps
        self.activepix = QPixmap("Resources\\active.png")
        self.issuespix = QPixmap("Resources\\issues.png")
        self.inactivepix = QPixmap("Resources\\inactive.png")
        self.noconnectionpix = QPixmap("Resources\\noconnection.png")

        self.scalePixmaps()
        
        #standard value for all displays is inactive (red)
        for statusLabel in self.statusDisplay:
            statusLabel.setPixmap(self.inactivepix_scaled)

        #set progressBar color to system accent color
        ui = UISettings()
        self.accentColor = ui.get_color_value(UIColorType.ACCENT)
        self.accentHex = f"#{self.accentColor.r:02x}{self.accentColor.g:02x}{self.accentColor.b:02x}"
        for progressBar in self.findChildren(QProgressBar):
            progressBar.setStyleSheet(f"""
            QProgressBar::chunk {{
                background-color: {self.accentHex};
            }}
            """)
        
        #initializing plots
        self.createPlots()

        self.setLocale(self.collection.settings.locale)

        #expanding tree for choosing displayed plots
        self.ui.treeWidget.expandAll()

        #creating the big logo
        self.logo = QPixmap("Resources\\meega_logo_small.png")
        self.ui.label_logo.setPixmap(self.logo)

        #creating menubar actiongroups (for exclusivity of selected options)
        self.modeGroup = QActionGroup(self.ui.menuStart)
        self.modeGroup.setExclusive(True)
        self.modeGroup.addAction(self.ui.actionFlight_Mode)
        self.modeGroup.addAction(self.ui.actionTest_Mode)

        self.appearanceGroup = QActionGroup(self.ui.menuAppearance)
        self.appearanceGroup.setExclusive(True)
        self.appearanceGroup.addAction(self.ui.actionDarkMode)
        self.appearanceGroup.addAction(self.ui.actionLightMode)

        #reference to the application object
        self.app = QApplication.instance()
        
    #internal functions

    def newFile(self):
        filepath = QFileDialog.getSaveFileName(
            self,
            "New File",
            self.collection.settings.defaultFilePath,
            "MEEGA-Files (*.meega)")
        if(DataHandling.CreateSave(bytes(filepath, "utf-8"))):
            self.collection.dataAccumulation.clearData()

    def openFile(self):
        filepath = QFileDialog.getOpenFileName(
            self,
            "Open File",
            self.collection.settings.defaultFilePath,
            "MEEGA-Files (*.meega)")
        if(DataHandling.ReadSave(bytes(filepath,"utf-8"))):
            self.collection.dataAccumulation.clearData()

    def scalePixmaps(self):
            #adjust pixmap sizes to label sizes
            label_size = self.statusDisplay[0].size()
            circle_diameter = min(label_size.width(), label_size.height())
            self.activepix_scaled = self.activepix.scaled(circle_diameter, circle_diameter, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.issuespix_scaled = self.issuespix.scaled(circle_diameter, circle_diameter, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.inactivepix_scaled = self.inactivepix.scaled(circle_diameter, circle_diameter, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.coldpix_scaled = self.noconnectionpix.scaled(circle_diameter, circle_diameter, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            #scale for connection status label
            connectionLabelSize = self.ui.connectionLabel.size()
            connectionCircle = min(connectionLabelSize.width(), connectionLabelSize.height())
            self.activepix_connection = self.activepix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.issuespix_connection = self.issuespix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.inactivepix_connection = self.inactivepix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.noconnectionpix_connection = self.noconnectionpix.scaled(connectionCircle, connectionCircle, Qt.KeepAspectRatio, Qt.SmoothTransformation)

    #override resizeEvent to rescale pixmaps when window size changes
    def resizeEvent(self, event):
            self.scalePixmaps()
            super().resizeEvent(event)

    #update of status displays according to current data in DataAccumulation, called every new frame
    @Slot()
    def displayStatus(self, index: int):
        #connection status
        match self.connectionStatus:
            case self.ACTIVE:
                self.ui.connectionLabel.setPixmap(self.activepix_connection)
            case self.ISSUES:
                self.ui.connectionLabel.setPixmap(self.issuespix_connection)
            case self.INACTIVE:
                self.ui.connectionLabel.setPixmap(self.inactivepix_connection)
            case self.NOCONNECTION:
                self.ui.connectionLabel.setPixmap(self.noconnectionpix_connection)

        #sensor / household status

        #fetching necessary data
        dataAccu = self.collection.dataAccumulation
        gatherIndex = self.collection.dataAccumulation.gatherIndex

        #fitting most recent status values from dataAccumulation into a single list with order according to statusDisplay list for handling via for loop
        statusList = np.concatenate((np.atleast_1d(dataAccu.household[PyID.Ambient_Pressure]), np.atleast_1d(dataAccu.household[PyID.Chamber_Temperature_1]), dataAccu.household[PyID.Accumulator_Pressure:PyID.Chamber_Pressure+1], dataAccu.household[PyID.Chamber_Temperature_2:PyID.Nozzle_3_Temperature+1], dataAccu.household[PyID.Nozzle_Servo:PyID.Sensorboard_T+1], dataAccu.household[PyID.Mainboard_T:PyID.Mainboard_V+1], dataAccu.household[PyID.Lift_Off:PyID.Start_Experiment+1]))
            
        #updating each label in statusDisplay according to statusList that was just created
        for i, display in enumerate(self.statusDisplay):
            match statusList[i]:
                case self.ACTIVE:
                    display.setPixmap(self.activepix_scaled)
                case self.ISSUES:
                    display.setPixmap(self.issuespix_scaled)
                case self.INACTIVE:
                    display.setPixmap(self.inactivepix_scaled)
                case self.ISSUESSTM:
                    display.setPixmap(self.issuespix_scaled)
            
        #special case for nozzle cover status display
        coverOpen = dataAccu.household[PyID.Nozzle_Open]
        coverClosed = dataAccu.household[PyID.Nozzle_Closed]
        if coverOpen and not coverClosed:
            self.ui.statusLabelCover.setPixmap(self.activepix_scaled)
        elif not coverOpen and coverClosed:
            self.ui.statusLabelCover.setPixmap(self.inactivepix_scaled)
        else:
            self.ui.statusLabelCover.setPixmap(self.issuespix_scaled)

        #special case for board temperature
        boardTemp = dataAccu.household[PyID.Mainboard_T]
        if boardTemp == 1:
            self.ui.statusLabelMainboardT.setPixmap(self.coldpix_scaled)
        elif boardTemp == 2:
            self.ui.statusLabelMainboardT.setPixmap(self.activepix_scaled)
        elif boardTemp == 3:
            self.ui.statusLabelMainboardT.setPixmap(self.issuespix_scaled)
        else:
            self.ui.statusLabelMainboardT.setPixmap(self.inactivepix_scaled)

    def createPlots(self):
        #time plot
        #indices of pressure and temperature series f.e. for axis assignment
        self.pressureIndices = [0,2,4,7,9,11]
        self.temperatureIndices = [1,3,5,6,8,10,12]

        #value tracking for time plots
        self.timeHighestPres = 0 #keep track of highest pressure for self-scaling axes
        self.timeHighestTemp = 0 #keep track of highest temperature for self-scaling axes
        self.currentIndex = -1 #keep track of last index added to time plot for extendPlots function

        #create Line Series for each sensor
        #ambient pressure, compare temperature, accumulator pressure, accumulator temperature, chamber pressure, chamber temperature1, chamber temperature 2, nozzle 1 pressure, nozzle 1 temperature, nozzle 2 pressure, nozzle 2 temperature, nozzle 3 pressure, nozzle 3 temperature
        self.timeSeries = [QLineSeries() for _ in range(DataAccumulation.sensorSize)]

        self.seriesColors = [
            # Light Mode
            [
                "#1F77B4", "#1F77B4",  # blue (ambient P, compare T)
                "#9467BD", "#9467BD",  # purple (accumulator P + T)
                "#2CA02C", "#2CA02C",  # green (chamber P + T)
                "#2CA02C",             # same green (chamber 2 T) (only chamber temp in use)
                "#8C564B", "#8C564B",  # brown (nozzle 1 P + T)
                "#FF7F0E", "#FF7F0E",  # orange (nozzle 2 P + T)
                "#D62728", "#D62728",  # red (nozzle 3 P + T)
            ],
            # Dark Mode:
            [
                "#4FA3D9", "#4FA3D9",
                "#B999E5", "#B999E5",
                "#5BC85B", "#5BC85B",
                "#5BC85B",
                "#C08A7A", "#C08A7A",
                "#FF9F4A", "#FF9F4A",
                "#FF6B6B", "#FF6B6B", 
            ]
        ]

        #create chart and disable legend
        self.timeChart = QChart()
        self.timeChart.legend().setVisible(False)

        #modify series stlyes
        self.updateLineSeriesThemes()

        #add series to chart
        for s in self.timeSeries:
            self.timeChart.addSeries(s)

        #create axes
        self.timeAxis = QValueAxis()
        self.timePressureAxis = QValueAxis()
        self.timeTemperatureAxis = QValueAxis()

        #label axes
        self.timeAxis.setTitleText("time in s")
        self.timePressureAxis.setTitleText("pressure in Pa")
        self.timeTemperatureAxis.setTitleText("temperature in K")

        #set initial ranges
        self.timePressureAxis.setRange(0, self.collection.settings.pressureAxeValue)
        self.timeTemperatureAxis.setRange(0, self.collection.settings.temperatureAxeValue)
        self.timeAxis.setRange(0, 1)
        self.timeAxis.setLabelFormat("%.1f")

        #add axes to chart
        self.timeChart.addAxis(self.timeAxis, Qt.AlignBottom)
        self.timeChart.addAxis(self.timePressureAxis, Qt.AlignLeft)
        self.timeChart.addAxis(self.timeTemperatureAxis, Qt.AlignRight)

        #attach axes to series
        for i, series in enumerate(self.timeSeries):
            if i in self.pressureIndices:
                series.attachAxis(self.timePressureAxis)
            else:
                series.attachAxis(self.timeTemperatureAxis)
            series.attachAxis(self.timeAxis)
            
        #create Layout
        self.timeLayout = QVBoxLayout(self.ui.timePlotGroupBox)
        self.timeLayout.setContentsMargins(2,0,2,2)

        #create ChartView and add to Layout
        self.timeChartView = QChartView(self.timeChart)
        self.timeChartView.setRenderHint(QPainter.Antialiasing)
        self.timeLayout.addWidget(self.timeChartView)

        #distance plot
        #create Line Series for pressure and temperature
        self.distancePSeries = QLineSeries()
        self.distanceTSeries = QLineSeries()

        #set title of series
        self.distancePSeries.setName("pressure")
        self.distanceTSeries.setName("temperature")

        #create Chart and add Series
        self.distanceChart = QChart()
        self.distanceChart.addSeries(self.distancePSeries)
        self.distanceChart.addSeries(self.distanceTSeries)

        #create axes
        self.distanceAxis = QValueAxis()
        self.distancePressureAxis = QValueAxis()
        self.distanceTemperatureAxis = QValueAxis()

        #label axes
        self.distancePressureAxis.setTitleText("pressure in Pa")
        self.distanceTemperatureAxis.setTitleText("temperature in K")

        #set initial ranges
        self.distanceAxis.setRange(0, 4)
        self.distancePressureAxis.setRange(0, self.collection.settings.pressureAxeValue)
        self.distanceTemperatureAxis.setRange(0, self.collection.settings.temperatureAxeValue)

        #add axes to chart
        self.distanceChart.addAxis(self.distancePressureAxis, Qt.AlignBottom)
        self.distanceChart.addAxis(self.distanceTemperatureAxis, Qt.AlignTop)
        self.distanceChart.addAxis(self.distanceAxis, Qt.AlignLeft)

        #attach axes to series
        self.distancePSeries.attachAxis(self.distancePressureAxis)
        self.distancePSeries.attachAxis(self.distanceAxis)
        self.distanceTSeries.attachAxis(self.distanceTemperatureAxis)
        self.distanceTSeries.attachAxis(self.distanceAxis)
        
        #create Layout
        self.distanceLayout = QVBoxLayout(self.ui.distancePlotGroupBox)
        self.distanceLayout.setContentsMargins(2,0,2,2)

        #add Chart to ChartView and Layout
        self.distanceChartView = QChartView(self.distanceChart)
        self.distanceChartView.setRenderHint(QPainter.Antialiasing)
        self.distanceLayout.addWidget(self.distanceChartView)

        self.connectItemsToSeries()

    def extendPlots(self, index: int):
        #fetching necessary data
        settings = self.collection.settings
        dataAccu = self.collection.dataAccumulation

        #distance plot
        self.distancePSeries.clear()
        self.distanceTSeries.clear()
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Accumulator_Pressure], 0)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Chamber_Pressure], 1)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_1_Pressure], 2)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_2_Pressure], 3)
        self.distancePSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_3_Pressure], 4)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Accumulator_Temperature], 0)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Chamber_Temperature_2], 1)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_1_Temperature], 2)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_2_Temperature], 3)
        self.distanceTSeries.append(self.collection.dataAccumulation.sensorData[dataAccu.gatherIndex][PyID.Nozzle_3_Temperature], 4)

        #skip if expanding mode needs an event that hasnt happened yet ie. expanding mode with LO or SOE as starting point with no recorded index (-1)
        if not (settings.timespanMode == Settings.EXPANDING and(
            (settings.expandFrom == Settings.LO and dataAccu.liftOffIndex == -1) or 
            (settings.expandFrom == Settings.SOE and dataAccu.startOfExperimentIndex == -1)
        )):
            #time plot
            #while loop to add all new data points until currentIndex matches gatherIndex from dataAccumulation
            while self.currentIndex < dataAccu.gatherIndex:
                self.currentIndex += 1

                #for loop for all sensor series in time plot
                for i, series in enumerate(self.timeSeries):

                    #if in scrolling mode, removing oldest point as long as covered timespand exceeds specified scrolling time from settings
                    if settings.timespanMode == Settings.SCROLLING:
                        while (series.at(series.count()-1).x() - series.at(0).x()) > settings.scrollingTimeSeconds:
                            series.remove(0)

                    #"index" is given by the signal that calls extendPlots and is the index in the dataAccumulation list of the newly added sensor Data
                    #if index matches currentIndex, simply append new data point
                    if index == self.currentIndex:
                        series.append(dataAccu.systemTime[index], dataAccu.sensorData[index][i])

                    #if index does not match currentIndex, calculate correct insert index
                    else:
                        #initialize insertIndex, mark as invalid with -1
                        insertIndex = -1

                        #in expanding mode, make sure that the data point is from after according event, calculate insert index by subtracting index of said event (or 0 if showing all points is selected)
                        if settings.timespanMode == Settings.EXPANDING:
                            if settings.expandFrom == Settings.LO and index > dataAccu.liftOffIndex:
                                insertIndex = index - dataAccu.liftOffIndex
                            elif settings.expandFrom == Settings.SOE and index > dataAccu.startOfExperimentIndex:
                                insertIndex = index - dataAccu.startOfExperimentIndex
                            elif settings.expandFrom == Settings.ALL:
                                insertIndex = index

                        #in scrolling mode, calculate insert index by subtracting the the global index of first data point currently displayed in the chart (highgest current globalIndex (gatherIndex) - number of points currently in series)
                        elif settings.timespanMode == Settings.SCROLLING:
                            insertIndex = index - (dataAccu.gatherIndex - series.count())

                        #insert data point at calculated index if valid
                        if insertIndex >= 0:
                            series.insert(insertIndex, QPointF(dataAccu.systemTime[index], dataAccu.sensorData[index][i]))

                    #save highest values for scaling of axes
                    if i in self.pressureIndices: #pressure Value
                        if dataAccu.sensorData[index][i] > self.timeHighestPres:
                            self.timeHighestPres = dataAccu.sensorData[index][i]
                    else: #temperature Value
                        if dataAccu.sensorData[index][i] > self.timeHighestTemp:
                            self.timeHighestTemp = dataAccu.sensorData[index][i]

                self.updateTimeAxis()

            #if too many points are added to the series, reduce them to avoid lag
            if self.timeSeries[0].count() > self.collection.settings.maxPlotPoints:
                self.doTaskSignal.emit(PlotWorker.REDUCEPOINTS)

        #update axes if one of them is in self-scaling mode
        if settings.temperatureAxeMode == Settings.SELFSCALING or settings.pressureAxeMode == Settings.SELFSCALING:
            self.updateAxes()
    
    #funtction that sets the time range on the x-axis
    def updateTimeAxis(self):
        settings = self.collection.settings
        dataAccu = self.collection.dataAccumulation

        #adjust time axis range from first to last point in arbitrarily chosen series (here: first series, ambient pressure)
        self.timeAxis.setRange(self.timeSeries[0].at(0).x(), self.timeSeries[0].at(self.timeSeries[0].count()-1).x())

    #function to update axes ranges according to current highest values and settings
    def updateAxes(self):
        #fetching necessary data
        settings = self.collection.settings

        #if axes are in fixed-value mode, set range from 0 to specified value in settings
        if settings.pressureAxeMode == Settings.FIXEDVALUE:
            self.timePressureAxis.setRange(0, settings.pressureAxeValue)
            self.distancePressureAxis.setRange(0, settings.pressureAxeValue)

        #if axes are in self-scaling mode, set range from 0 to highest recorded value (compute it on spot for distance plot)
        else:
            self.timePressureAxis.setRange(0, self.timeHighestPres)
            self.distancePressureAxis.setRange(0, max(point.x() for point in self.distancePSeries.points()))

        #same for temperature axes
        if settings.temperatureAxeMode == Settings.FIXEDVALUE:
            self.timeTemperatureAxis.setRange(0, settings.temperatureAxeValue)
            self.distanceTemperatureAxis.setRange(0, settings.temperatureAxeValue)
        else:
            self.timeTemperatureAxis.setRange(0, self.timeHighestTemp)
            self.distanceTemperatureAxis.setRange(0, max(point.x() for point in self.distanceTSeries.points()))

    #connect index value of series to according tree item so that it can be called in onItemChanged, when user checks or unchecks items in the tree
    def connectItemsToSeries(self):
        tree = self.ui.treeWidget
        tree.topLevelItem(0).child(0).child(3).setData(0, Qt.UserRole, PyID.Ambient_Pressure)  # Ambient Pressure
        tree.topLevelItem(0).child(1).child(3).setData(0, Qt.UserRole, PyID.Compare_Temperature)  # Compare Temperature
        tree.topLevelItem(0).child(0).child(2).setData(0, Qt.UserRole, PyID.Accumulator_Pressure)  # Accumulator Pressure
        tree.topLevelItem(0).child(1).child(2).setData(0, Qt.UserRole, PyID.Accumulator_Temperature)  # Accumulator Temperature
        tree.topLevelItem(0).child(0).child(1).setData(0, Qt.UserRole, PyID.Chamber_Pressure)  # Chamber Pressure
        tree.topLevelItem(0).child(1).child(1).setData(0, Qt.UserRole, PyID.Chamber_Temperature_2)  # Chamber (2) Temperature
        tree.topLevelItem(0).child(0).child(0).child(0).setData(0, Qt.UserRole, PyID.Nozzle_1_Pressure)  # Nozzle 1 Pressure
        tree.topLevelItem(0).child(1).child(0).child(0).setData(0, Qt.UserRole, PyID.Nozzle_1_Temperature)  # Nozzle 1 Temperature
        tree.topLevelItem(0).child(0).child(0).child(1).setData(0, Qt.UserRole, PyID.Nozzle_2_Pressure)  # Nozzle 2 Pressure
        tree.topLevelItem(0).child(1).child(0).child(1).setData(0, Qt.UserRole, PyID.Nozzle_2_Temperature)  # Nozzle 2 Temperature
        tree.topLevelItem(0).child(0).child(0).child(2).setData(0, Qt.UserRole, PyID.Nozzle_3_Pressure)  # Nozzle 3 Pressure
        tree.topLevelItem(0).child(1).child(0).child(2).setData(0, Qt.UserRole, PyID.Nozzle_3_Temperature)  # Nozzle 3 Temperature

    #functions to apply darkmode/lightmode to app and charts, called by menu actions
    def setLightTheme(self):
        palette = QPalette()

        palette.setColor(QPalette.Window, QColor(245, 245, 245))
        palette.setColor(QPalette.WindowText, QColor(20, 20, 20))

        palette.setColor(QPalette.Base, QColor(255, 255, 255))
        palette.setColor(QPalette.AlternateBase, QColor(240, 240, 240))

        palette.setColor(QPalette.Text, QColor(20, 20, 20))
        palette.setColor(QPalette.Button, QColor(240, 240, 240))
        palette.setColor(QPalette.ButtonText, QColor(20, 20, 20))

        palette.setColor(QPalette.Highlight, QColor(0, 120, 215))
        palette.setColor(QPalette.HighlightedText, QColor(255, 255, 255))

        palette.setColor(QPalette.ToolTipBase, QColor(255, 255, 255))
        palette.setColor(QPalette.ToolTipText, QColor(20, 20, 20))

        self.app.setPalette(palette)

        self.app.setStyleSheet("""
            QMenuBar { background:#f5f5f5; color:#141414; }
            QMenuBar::item:selected { background:#e6e6e6; border-radius: 6px;}
            QToolBar, QStatusBar { background:#f5f5f5; color:#141414; }

            QProgressBar {
                min-height: 20px;
                max-height: 20px;
                border: none;
                border-radius: 7px;
                background: #e6e6e6;
                color: #000000;
                text-align: center;
            }
            QProgressBar::chunk {
                border-radius: 7px;
            }
            QTreeWidget {
                background: #f5f5f5;
                alternate-background-color: #f5f5f5;
                border: none;
            }

            QTreeWidget::item:selected {
                background: #0078d7;
                color: white;
            }

            QTreeWidget::item:hover {
                background: #e6e6e6;
            }
        """)

        self.applyLightmodeToCharts()
        self.updateLineSeriesThemes()
        self.collection.liveValuesWidget.applyLightMode()

    def setDarkTheme(self):
        palette = QPalette()

        palette.setColor(QPalette.Window, QColor(43, 43, 43))
        palette.setColor(QPalette.WindowText, QColor(220, 220, 220))

        palette.setColor(QPalette.Base, QColor(30, 30, 30))
        palette.setColor(QPalette.AlternateBase, QColor(37, 37, 38))

        palette.setColor(QPalette.Text, QColor(220, 220, 220))
        palette.setColor(QPalette.Button, QColor(60, 63, 65))
        palette.setColor(QPalette.ButtonText, QColor(220, 220, 220))

        palette.setColor(QPalette.Highlight, QColor(0, 120, 215))
        palette.setColor(QPalette.HighlightedText, QColor(255, 255, 255))

        palette.setColor(QPalette.ToolTipBase, QColor(50, 50, 50))
        palette.setColor(QPalette.ToolTipText, QColor(255, 255, 255))

        self.app.setPalette(palette)

        self.app.setStyleSheet("""
            QMenuBar { background:#2b2b2b; color:#dcdcdc; }
            QMenuBar::item:selected { background:#3c3f41; border-radius: 6px;}
            QToolBar, QStatusBar { background:#2b2b2b; color:#dcdcdc; }

            QMenu {
                background: #2b2b2b;
                color: #dcdcdc;
                border: 1px solid #3a3a3a;
                border-radius: 8px;
                padding: 0px;
            }

            QMenu::item {
                padding: 4px 14px 4px 28px;
                margin: 0px;
                border-radius: 6px;
            }

            QMenu::item:selected {
                background: #3c3f41;
                color: #ffffff;
            }

            QMenu::item:disabled {
                color: #8a8a8a;
            }

            QMenu::indicator {
                left: 8px;
            }

            QMenu::separator {
                height: 1px;
                background: #3a3a3a;
                margin: 4px 8px;
            }

            QProgressBar {
                min-height: 20px;
                max-height: 20px;
                border: none;
                border-radius: 7px;
                background: #3c3f41;
                color: #ffffff;
                text-align: center;
            }
            QProgressBar::chunk {
                border-radius: 7px;
            }
            QTreeWidget {
                background: #2b2b2b;
                alternate-background-color: #2b2b2b;
                border: none;
            }

            QTreeWidget::item:selected {
                background: #0078d7;
                color: white;
            }

            QTreeWidget::item:hover {
                background: #3c3f41;
            }
        """)

        self.applyDarkmodeToCharts()
        self.updateLineSeriesThemes()
        self.collection.liveValuesWidget.applyDarkMode()

    def updateLineSeriesThemes(self):
        #get 1 for darkmode and 0 for light mode
        theme = self.ui.actionDarkMode.isChecked()

        #go through all series
        for i, s in enumerate(self.timeSeries):

            #create QPen with correct color
            pen = QPen(QColor(self.seriesColors[theme][i]))

            #set width of the line
            pen.setWidth(2)

            #apply the style to series
            s.setPen(pen)

        coloredSquares = []
        for i in range(len(self.timeSeries)):
            pixmap = QPixmap(15, 15)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            painter.setBrush(QColor(self.seriesColors[theme][i]))
            painter.setPen(Qt.NoPen)
            painter.drawRoundedRect(0, 0, 15, 15, 4, 4)
            painter.end()
            coloredSquares.append(pixmap)

        #update the icon of the tree Widget items. hard coded because not really possible with a loop :(
        #(except for a recursicve algorithm that would be overkill at this point)
        tree = self.ui.treeWidget
        tree.topLevelItem(0).child(0).child(3).setIcon(0 ,coloredSquares[PyID.Ambient_Pressure])  # Ambient Pressure
        tree.topLevelItem(0).child(1).child(3).setIcon(0, coloredSquares[PyID.Compare_Temperature])  # Compare Temperature
        tree.topLevelItem(0).child(0).child(2).setIcon(0, coloredSquares[PyID.Accumulator_Pressure])  # Accumulator Pressure
        tree.topLevelItem(0).child(1).child(2).setIcon(0, coloredSquares[PyID.Accumulator_Temperature])  # Accumulator Temperature
        tree.topLevelItem(0).child(0).child(1).setIcon(0, coloredSquares[PyID.Chamber_Pressure])  # Chamber Pressure
        tree.topLevelItem(0).child(1).child(1).setIcon(0, coloredSquares[PyID.Chamber_Temperature_2]) #Chamber (2) Temperature
        tree.topLevelItem(0).child(0).child(0).child(0).setIcon(0, coloredSquares[PyID.Nozzle_1_Pressure])  # Nozzle 1 Pressure
        tree.topLevelItem(0).child(1).child(0).child(0).setIcon(0, coloredSquares[PyID.Nozzle_1_Temperature])  # Nozzle 1 Temperature
        tree.topLevelItem(0).child(0).child(0).child(1).setIcon(0, coloredSquares[PyID.Nozzle_2_Pressure])  # Nozzle 2 Pressure
        tree.topLevelItem(0).child(1).child(0).child(1).setIcon(0, coloredSquares[PyID.Nozzle_2_Temperature])  # Nozzle 2 Temperature
        tree.topLevelItem(0).child(0).child(0).child(2).setIcon(0, coloredSquares[PyID.Nozzle_3_Pressure])  # Nozzle 3 Pressure
        tree.topLevelItem(0).child(1).child(0).child(2).setIcon(0, coloredSquares[PyID.Nozzle_3_Temperature])  # Nozzle 3 Temperature

    #function to make diagrams darkmode themed
    def applyDarkmodeToCharts(self):
        #Chart Background
        self.timeChart.setBackgroundBrush(QBrush(QColor("#2b2b2b")))
        self.distanceChart.setBackgroundBrush(QBrush(QColor("#2b2b2b")))

        #Title
        self.timeChart.setTitleBrush(QBrush(QColor("#dddddd")))
        self.distanceChart.setTitleBrush(QBrush(QColor("#dddddd")))

        #Legend
        self.distanceChart.legend().setLabelColor(QColor("#dddddd"))
        self.distanceChart.legend().setBrush(QBrush(QColor("#2b2b2b")))
        self.timeChart.legend().setPen(QPen(QColor("#555555")))

        #Axes
        for axis in [self.timeAxis, self.timePressureAxis, self.timeTemperatureAxis, self.distanceAxis, self.distancePressureAxis, self.distanceTemperatureAxis]:
            axis.setLabelsColor(QColor("#dddddd"))
            axis.setLinePen(QPen(QColor("#777777")))
            axis.setGridLinePen(QPen(QColor("#444444")))
            axis.setMinorGridLinePen(QPen(QColor("#333333")))
            axis.setTitleBrush(QBrush(QColor("#dddddd")))

    #function to make diagrams lightmode themed
    def applyLightmodeToCharts(self):
        #Chart Background
        self.timeChart.setBackgroundBrush(QBrush())
        self.distanceChart.setBackgroundBrush(QBrush())

        #Title
        self.timeChart.setTitleBrush(QBrush())
        self.distanceChart.setTitleBrush(QBrush())

        #Legend
        self.timeChart.legend().setLabelColor(QColor())
        self.timeChart.legend().setBrush(QBrush())
        self.timeChart.legend().setPen(QPen())

        self.distanceChart.legend().setLabelColor(QColor())
        self.distanceChart.legend().setBrush(QBrush())
        self.distanceChart.legend().setPen(QPen())

        #Axes
        for axis in [self.timeAxis, self.timePressureAxis, self.timeTemperatureAxis, self.distanceAxis, self.distancePressureAxis, self.distanceTemperatureAxis]:
            axis.setLabelsColor(QColor())
            axis.setLinePen(QPen(QColor(150, 150, 150)))
            axis.setGridLinePen(QPen(QColor(200, 200, 200), 1))
            axis.setMinorGridLinePen(QPen(QColor(220, 220, 220), 1))
            axis.setTitleBrush(QBrush())

    def connect(self):
        #connection of signals and slots, called in late-init in ClassCollection after all components are created

        self.ui.actionFlight_Mode.triggered.connect(self.modeSwitched)
        self.ui.actionTest_Mode.triggered.connect(self.modeSwitched)

        self.ui.actionDarkMode.triggered.connect(self.setDarkTheme)
        self.ui.actionLightMode.triggered.connect(self.setLightTheme)

        self.ui.actionReset_Progress_Bar.triggered.connect(self.resetProgressBar)

        self.ui.actionQuit.triggered.connect(self.collection.shutdown)

        self.ui.treeWidget.itemChanged.connect(self.onItemChanged)

        self.ui.actionReconnect.triggered.connect(self.collection.connectionWindow.applySettings)

        self.ui.actionFileNew.triggered.connect(self.newFile)
        self.ui.actionFileOpen.triggered.connect(self.openFile)

    #override closeEvent to ensure proper thread termination and application exit when trying to close the main window
    def closeEvent(self, event):
        self.collection.shutdown()
        event.accept()
        super().closeEvent(event)

    #external functions (slots)

    #onNewFrame is called by Signal in DataAccumulation every time a new frame has been added, calls extendPlots, which is necessary updates for every new frame
    @Slot(int)
    def onNewFrame(self, index: int):
        self.extendPlots(index)

    #slot for mode switching (flight/test) from menubar
    @Slot()
    def modeSwitched(self):
        if self.modeGroup.checkedAction() == self.ui.actionFlight_Mode:
            #update settings value
            self.collection.settings.mode = Settings.FLIGHT

            #update label in main window
            self.ui.label_mode.setText("Flight Mode")

            #disable button for opening control panel
            self.ui.actionControl_Panel.setEnabled(False)

            #clear and hide control panel
            self.collection.controlPanel.clearPanel()
            self.collection.controlPanel.hide()

        else:
            #update settings value
            self.collection.settings.mode = Settings.TEST

            #update label in main window
            self.ui.label_mode.setText("Test Mode")

            #enable button for opening control panel
            self.ui.actionControl_Panel.setEnabled(True)

        #send telecommand with updated mode
        self.collection.telecommand.newTCFrame()
        self.collection.telecommand.sendInit()

    #function to apply settings from collection to main window ui elements, called after startup dialog is closed
    @Slot()
    def applySettings(self):
        if self.collection.settings.mode == Settings.FLIGHT:
            self.ui.actionFlight_Mode.setChecked(True)
        else:
            self.ui.actionTest_Mode.setChecked(True)
        self.setLocale(self.collection.settings.locale)
        self.modeSwitched()

    #override of itemChanged signal from treeWidget in main window, called when user checks or unchecks an item in the tree to add or remove the according series from the time plot
    @Slot(QTreeWidgetItem, int)
    def onItemChanged(self, item, column):
        #get series index from item data
        if item.data(0, Qt.UserRole) is None:
            return
        seriesIndex = item.data(0, Qt.UserRole)

        #get series from series index
        series = self.timeSeries[seriesIndex]

        #add or remove series from chart according to check state of item
        #add if checked and not already added
        if item.checkState(0) == Qt.Checked:
            if series not in self.timeChart.series():
                self.timeChart.addSeries(series)

                #time axis
                series.attachAxis(self.timeAxis)

                #add correct value axis
                if seriesIndex in self.pressureIndices:
                    series.attachAxis(self.timePressureAxis)
                else:
                    series.attachAxis(self.timeTemperatureAxis)

        #remove if unchecked and currently added
        else:
            if series in self.timeChart.series():
                self.timeChart.removeSeries(series)

    #slot to replace series, called by PlotWorker Thread when needing to replace entire series
    @Slot(int, list)
    def replaceSeries(self, seriesIndex: int, points: list[QPointF]):
        self.timeSeries[seriesIndex].replace(points)

    #slot to clear series, called by PlotWorker Thread when needing to clear entire series
    @Slot(int)
    def clearSeries(self, seriesIndex: int):
        self.timeSeries[seriesIndex].clear()
    
    #update currentIndex, highest values after plot Rebuild, called by PlotWorker Thread
    @Slot(int, float, float)
    def updatePlotMetrics(self, currentIndex: int, highestPres: float, highestTemp: float):
        self.currentIndex = currentIndex
        self.timeHighestPres = highestPres
        self.timeHighestTemp = highestTemp

    #slot to set connection status, called by DataAccumulation when connection status changes, needed for proper decoupling of threads
    @Slot(int)
    def setConnectionStatus(self, status: int):
        self.connectionStatus = status

    @Slot()
    def updateLOTimer(self):
        #get the current time
        currentTime = QDateTime.currentDateTime(self.collection.settings.timeZone)

        #get difference in seconds of estimated launch time and current time
        secstoLO = currentTime.secsTo(self.collection.settings.estimatedLaunchTime)

        #if value isnt negative (lift off isnt in the past), set the lift off counter to the difference
        if secstoLO >= 0:
            timetoLO = QTime(0, 0).addSecs(secstoLO)
            self.ui.label_time.setText("T - ")
            self.ui.time_counter.setText(timetoLO.toString("h:mm:ss"))

        else:
            timesinceLO = QTime(0, 0).addSecs(-secstoLO)
            self.ui.label_time.setText("T + ")
            self.ui.time_counter.setText(timesinceLO.toString("h:mm:ss"))

    @Slot()
    def updateProgressBar(self):
        #fetch frequently used data
        settings = self.collection.settings

        #get the current time
        currentTime = QDateTime.currentDateTime(self.collection.settings.timeZone)

        #proceed if power on has been detected
        if not (settings.powerOnTime is None):
            #fill pre-flight progressBar, as pre-flight sequence starts when power is on
            self.ui.progressBar_PF.setValue(100)

            #check if still in pre flight sequence or already further into the sequence (lift off signal already detected)
            if settings.LOTime is None:

                #if in pre-flight sequence, increase preflight time tracker to time passed since power on
                preFlightTime = QTime(0, 0).addSecs(settings.powerOnTime.secsTo(currentTime))
                self.ui.progressBar_PF.setFormat(preFlightTime.toString("mm:ss"))

            #else, already further into the sequence
            else:

                #fill lift-off progressBar, as lift-Off has been reached
                self.ui.progressBar_LO.setValue(100)

                #get time that has passed since liftOff
                secsSinceLO = settings.LOTime.secsTo(currentTime)

                #check if still in lift off-sequence, or already in nose cone ejection sequence
                if secsSinceLO <= settings.LOtoExpPrepSecs and settings.SOETime is None:

                    #set lift-off time tracker to current time since LO
                    timeSinceLO = QTime(0, 0).addSecs(secsSinceLO)
                    self.ui.progressBar_LO.setFormat(timeSinceLO.toString("mm:ss"))

                #check if still in nose cone ejecion sequence, or already further into the sequence (SOE reached)
                elif settings.SOETime is None:

                    #set nose cone ejection progress bar to percentage of nose cone ejection that has passed
                    secsSinceExpPrepStart = settings.LOTime.secsTo(currentTime) - settings.LOtoExpPrepSecs
                    self.ui.progressBar_SODS.setValue(100 * secsSinceExpPrepStart / settings.ExpPreptoSOESecs)

                    #set exp prep timeTracker to current Time since expPrep Start
                    timeSinceExpPrepStart = QTime(0, 0).addSecs(secsSinceExpPrepStart)
                    self.ui.progressBar_SODS.setFormat(timeSinceExpPrepStart.toString("mm:ss"))

                #else, SOE has been reached
                else:

                    #fill exp prep progress bar, if not already filled
                    self.ui.progressBar_SODS.setValue(100)

                    #check if still in valve sequence or already in experiment run sequence (nozzle cover opened)
                    if settings.NozzleOpenTime is None:

                        #get time since SOE
                        secsSinceSOE = settings.SOETime.secsTo(currentTime)

                        #set the progressBar value to fraction of valve sequence that has passed
                        if secsSinceSOE <= settings.SOEtoNozzleOpenSecs:
                            self.ui.progressBar_SOE.setValue(100 * secsSinceSOE / settings.SOEtoNozzleOpenSecs)

                        #set valve sequence time tracker to time that has passed since SOE
                        timeSinceSOE = QTime(0, 0).addSecs(secsSinceSOE)
                        self.ui.progressBar_SOE.setFormat(timeSinceSOE.toString("mm:ss"))

                    #Nozzle has been opened, nozzle cover is opening, experiment run starts
                    else:

                        #fill SOE progress bar, if not already filled
                        self.ui.progressBar_SOE.setValue(100)

                        #check if still in experiment sequence, or EOE has already been reached
                        if settings.EOETime is None:

                            #get time since nozzleOpen
                            secsSinceNozzleOpen = settings.NozzleOpenTime.secsTo(currentTime)

                            #set the progressBar value to fraction of experiment that has passed
                            if secsSinceNozzleOpen <= settings.nozzleOpenToEOESecs:
                                self.ui.progressBar_SOE.setValue(100 * secsSinceNozzleOpen / settings.nozzleOpenToEOESecs)

                            #set experiment time tracker to time that has passed since SOE
                            timeSinceNozzleOpen = QTime(0, 0).addSecs(secsSinceNozzleOpen)
                            self.ui.progressBar_ER.setFormat(timeSinceNozzleOpen.toString("mm:ss"))

                        #EOE has been reached
                        else:
                        
                            #fill exp progress bar, if not already filled
                            self.ui.progressBar_ER.setValue(100)

                            #if experiment state is shutdown (9), fill shutdown progress bar
                            if self.collection.dataAccumulation.household[PyID.Experiment_State] == 9:
                                self.ui.progressBar_SD.setValue(100)

    @Slot()
    def resetProgressBar(self):
        #set all collected times to None
        self.collection.settings.powerOnTime = None
        self.collection.settings.LOTime = None
        self.collection.settings.SOETime = None
        self.collection.settings.nozzleOpenTime = None
        self.collection.settings.EOETime = None

        #set all Progress Bars to 0
        self.ui.progressBar_PF.setValue(0)
        self.ui.progressBar_LO.setValue(0)
        self.ui.progressBar_SODS.setValue(0)
        self.ui.progressBar_SOE.setValue(0)
        self.ui.progressBar_ER.setValue(0)
        self.ui.progressBar_SD.setValue(0)

        #set all Progress Bar texts to 00:00
        self.ui.progressBar_PF.setFormat("00:00")
        self.ui.progressBar_LO.setFormat("00:00")
        self.ui.progressBar_SODS.setFormat("00:00")
        self.ui.progressBar_SOE.setFormat("00:00")
        self.ui.progressBar_ER.setFormat("00:00")
        self.ui.progressBar_SD.setFormat("00:00")

#class to define the startup dialog window
class GSStart(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_StartDialog()
        self.ui.setupUi(self)
        self.collection = collection
        self.ui.languageComboBox.setItemData(0, "en")
        self.ui.languageComboBox.setItemData(1, "de")
        self.ui.modeComboBox.setItemData(0, Settings.TEST)
        self.ui.modeComboBox.setItemData(1, Settings.FLIGHT)

        self.ui.saveFileButton.clicked.connect(self.getFilepath)

        #if dialog i rejected, call shutdown of collection to terminate application
        self.rejected.connect(self.collection.shutdown)
        #if dialog is accepted, fetch settings from ui elements
        self.accepted.connect(self.fetchSettings)

    #override closeEvent to ensure proper thread termination and application exit when trying to close the dialog
    def closeEvent(self, event):
        self.collection.shutdown()
        event.accept()
        super().closeEvent(event)

    @Slot()
    def getFilepath(self):
        #open explorer for choosing filepath
        filepath, _ = QFileDialog.getOpenFileName(
            self,
            "Open Save File",
            os.path.dirname(os.path.abspath(__file__)),
            "MEEGA-Dateien (*.meega)"
        )

        self.ui.saveFileEdit.setText(filepath)
    
    #fetch settings from ui elements and store them in settings
    @Slot()
    def fetchSettings(self):
        self.collection.settings.language = self.ui.languageComboBox.currentData()
        self.collection.settings.connector = self.ui.connectionComboBox.currentText()
        self.collection.settings.mode = self.ui.modeComboBox.currentData()
        self.collection.settings.filepath = self.ui.saveFileEdit.text()
        self.collection.settings.estimatedLaunchTime = QDateTime(QDate.currentDate(), self.ui.launchTimeTimeEdit.time(), self.collection.settings.timeZone)

        #Start DataHandling loop
        self.collection.dataHandlingThread.start()

        #lateInit for events that need DataHandling to be running
        self.collection.mainWindow.connect()
        time.sleep(0.1)  #ensure DataHandling is initialized before CalibrationWindow tries to read points and ComPort is set
        self.collection.calibrationWindow.initializeCalibrationPoints()

#class that defines window for defining (approximate) launch time
class GSLaunchTime(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_LaunchTimeDialog()
        self.ui.setupUi(self)
        self.collection = collection

        #if dialog is accepted, fetch launch time from ui element
        self.accepted.connect(self.fetchSettings)
    
    #fetch launch time from ui element and store it in settings
    @Slot()
    def fetchSettings(self):
        self.collection.settings.estimatedLaunchTime = QDateTime(QDate.currentDate(), self.ui.launchTimeEdit.time(), self.collection.settings.timeZone)

#class that defines window for displaying error messages
class GSError(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_ErrorDialog()
        self.ui.setupUi(self)
        self.collection = collection
 
#class that defines control panel window for test mode
class GSControl(QWidget):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_controlPanel()
        self.ui.setupUi(self)
        self.collection = collection

        #Initialize control states
        self.valveControl = 0  # closed
        self.ledState = 0      # False (Off)
        self.servoAngle = 0 # in 
        self.dryRunActive = 0 #False
        self.testRunStart = 0 #False (no signal to start test run)
        self.testRunStop = 0 #False (no signal to abort test run)

        #Initialize duration values
        self.valveDelay = QTime(0, 0, 0)
        self.servoDelay = QTime(0, 0, 0)
        self.EOEDelay = QTime(0, 0, 0)

        #Connect signals to slots
        self.connectSignals()
        
    #connect ui buttons to their respective slots
    def connectSignals(self):
        # Valve controls
        self.ui.openValveButton.clicked.connect(self.openValve)
        self.ui.closeValveButton.clicked.connect(self.closeValve)

        # Servo controls
        self.ui.setServoButton.clicked.connect(self.setServoAngle)

        # LED controls
        self.ui.ledOnButton.clicked.connect(self.onLED)
        self.ui.ledOffButton.clicked.connect(self.offLED)

        # Test run controls
        self.ui.startTestButton.clicked.connect(self.startTest)
        self.ui.stopTestButton.clicked.connect(self.stopTest)

        # Dry run control
        self.ui.dryRunOnButton.clicked.connect(self.dryRunSwitch)

        # Reset buttons
        self.ui.valveResetButton.clicked.connect(self.resetValveDelay)
        self.ui.servoResetButton.clicked.connect(self.resetServoDelay)
        self.ui.EOEResetButton.clicked.connect(self.resetEOEDelay)
    
    # external functions for ui controls
    # similar construction for all:
    # set python internal control state
    # create new telecommand frame with function provided by Telecommand class (only if this event should trigger sending a telecommand)
    # update telecommand frame with current control states and durations (only if this event should trigger sending a telecommand)
    # send telecommand frame with function provided by Telecommand class (only if this event should trigger sending a telecommand)

    # Valve control slots
    @Slot()
    def openValve(self):
        self.valveControl = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
    @Slot()
    def closeValve(self):
        self.valveControl = 0
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()

    # Servo control slot
    @Slot()
    def setServoAngle(self):
        self.servoAngle = self.ui.servoValueBox.value()
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()

    # LED control slots
    @Slot()
    def onLED(self):
        self.ledState = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
    @Slot()
    def offLED(self):
        self.ledState = 0
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()

    # Test run control slots
    # special cases, immediately set back to false after sending to avoid starting over again after one run
    @Slot()
    def startTest(self):
        #update delays from input elements before starting test
        self.setDelays()
        self.testRunStart = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
        self.testRunStart = 0
        #starting queue for sending telecommand that start experiment is no longer turned on after sending
        self.collection.telecommand.expStartQueue = True
    @Slot()
    def stopTest(self):
        self.testRunStop = 1
        self.collection.telecommand.newTCFrame()
        self.updateTCFrame()
        self.collection.telecommand.sendInit()
        self.testRunStop = 0

    # Dry run control slot
    @Slot()
    def dryRunSwitch(self):
        if self.ui.dryRunOnButton.isChecked():
            self.dryRunActive = 1
        else:
            self.dryRunActive = 0

    # Reset duration slots
    # set all input elements and internal variables to zero
    @Slot()
    def resetValveDelay(self):
        self.ui.valveTimeEdit.setTime(QTime(0, 0, 0))
        self.ui.valveMilliEdit.setText("000")
        self.valveDelay = QTime(0, 0, 0)
    @Slot()
    def resetServoDelay(self):
        self.ui.servoTimeEdit.setTime(QTime(0, 0, 0))
        self.ui.servoMilliEdit.setText("000")
        self.servoDelay = QTime(0, 0, 0)
    @Slot()
    def resetEOEDelay(self):
        self.ui.EOETimeEdit.setTime(QTime(0, 0, 0))
        self.ui.EOEMilliEdit.setText("000")
        self.EOEDelay = QTime(0, 0, 0)

    # internal functions

    # setDelays is called before starting a test run to update internal delay variables from input elements
    def setDelays(self):
        self.valveDelay = self.ui.valveTimeEdit.time().addMSecs(int(self.ui.valveMilliEdit.text()))
        self.servoDelay = self.ui.servoTimeEdit.time().addMSecs(int(self.ui.servoMilliEdit.text()))
        self.EOEDelay = self.ui.EOETimeEdit.time().addMSecs(int(self.ui.EOEMilliEdit.text()))

    # Update the telecommand frame with current control states and durations
    def updateTCFrame(self):
        #times are sent in milliseconds, so convert QTime to milliseconds
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Valve_Delay, (self.valveDelay.minute()*60 + self.valveDelay.second())*1000 + self.valveDelay.msec())
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Servo_Delay, (self.servoDelay.minute()*60 + self.servoDelay.second())*1000 + self.servoDelay.msec())
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.EoE_Delay, (self.EOEDelay.minute()*60 + self.EOEDelay.second())*1000 + self.EOEDelay.msec())
        #PowerOffDelay fehlt
        #NozzleOnDelay fehlt
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Dry_Run, self.dryRunActive)
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.LED_Control, self.ledState)
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Servo_Control, floor(self.servoAngle))
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Valve_Control, self.valveControl)
        #Camera control fehlt
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Test_Abort, self.testRunStop)
        DataHandling.WriteFrame(self.collection.telecommand.tcframe, TCID.Test_Run, self.testRunStart)

    # clearPanel is called when switching to flight mode to reset all control states and input elements to default values in order to avoid sending unintended data when first opening the control panel in test mode again
    def clearPanel(self):
        self.valveControl = 0
        self.ledState = 0
        self.servoAngle = 0
        self.ui.servoValueBox.setValue(0)
        self.dryRunActive = 0
        self.ui.dryRunOnButton.setChecked(False)
        self.testRunStart = 0
        self.testRunStop = 0
        self.resetValveDelay()
        self.resetServoDelay()
        self.resetEOEDelay()

#class that defines window for connection settings
class GSConnection(QDialog):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_ConnectionDialog()
        self.ui.setupUi(self)
        self.collection = collection
        # initialize ui elements according to current settings, choose combobox index from currently stored connector setting
        self.ui.ConnectorBox.setCurrentIndex(int(self.collection.settings.connector[-1])-1)

        #connect applySettings function
        self.ui.buttonBox.accepted.connect(self.applySettings)
    
    #apply settings from ui elements to settings and DataHandling, currently only serial connector settings is functional, tcp not planned
    def applySettings(self):
        self.collection.settings.connector = self.ui.ConnectorBox.currentText().encode("utf-8")
        DataHandling.SetPort(self.collection.settings.connector)

class GSCalibration(QWidget):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_Calibration()
        self.ui.setupUi(self)
        self.collection = collection

        #initialize variables
        self.selectedSensor = 0 #internal tracking of currently selected sensor from comboBox
        self.selectedEntry = 0 #internal tracking of currently selected calibration point (1,2,3) from radio buttons
        self.currentUnit = "" #unit string for currently selected sensor

        #create calibration point storage lists
        self.analogValues = [[0] * 2 for x in range(DataAccumulation.sensorSize)]
        self.digitalValues = [[0] * 2 for x in range(DataAccumulation.sensorSize)]

        #create exclusive button group for radio buttons
        self.buttonGroup = QButtonGroup(self)
        self.buttonGroup.addButton(self.ui.radioButton1)
        self.buttonGroup.addButton(self.ui.radioButton2)
        #self.buttonGroup.addButton(self.ui.radioButton3)
        self.buttonGroup.setExclusive(True)

        #connect clicking of radio buttons and state change of use current digital checkbox to disablingLogic function
        self.ui.radioButton1.clicked.connect(self.disablingLogic)
        self.ui.radioButton2.clicked.connect(self.disablingLogic)
        #self.ui.radioButton3.clicked.connect(self.disablingLogic)
        self.ui.useCurrentDigital.stateChanged.connect(self.disablingLogic)

        #click once to ensure proper enabling/disabling of lineEdits at startup
        self.ui.radioButton1.click()

        #connect sensor selection and ok button to their respective functions
        self.ui.sensorSelect.currentIndexChanged.connect(self.selectSensor)
        self.ui.okButton.clicked.connect(self.newCalibrationPoint)
    
    #initialize calibration point storage lists from Calibration Point savefile using DataHandling function
    #is called in late initialization in GSMain to ensure DataHandling has been initialized before using its functions
    def initializeCalibrationPoints(self):
        #go through all sensors
        for sensorID, pointSet in enumerate(self.analogValues):

            #go through all calibration points in that sensor
            for pointID, point in enumerate(pointSet):

                #read analog value from dataHandling and save it in storage list
                self.analogValues[sensorID][pointID] = DataHandling.ReadPoint(sensorID, pointID).analog

                #read digital value from dataHandling and save it in storage list
                self.digitalValues[sensorID][pointID] = DataHandling.ReadPoint(sensorID, pointID).digital

        #select first sensor to display its now initialized values at startup
        self.selectSensor()

    #update the displayed sensor value
    def updateValue(self, index: int):
        mappedValue = self.collection.dataAccumulation.sensorData[self.collection.dataAccumulation.gatherIndex][self.selectedSensor]
        self.ui.currentValue.setText(str(mappedValue) + " " + self.currentUnit)
        if self.ui.useCurrentDigital.isChecked():
            match self.selectedEntry:
                case 0:
                    self.ui.digitalEdit1.setText(str(self.collection.dataAccumulation.currentDigitals[self.selectedSensor]))
                case 1:
                    self.ui.digitalEdit2.setText(str(self.collection.dataAccumulation.currentDigitals[self.selectedSensor]))
                #case 2:
                #    self.ui.digitalEdit3.setText(str(self.collection.dataAccumulation.currentDigitals[self.selectedSensor]))
    
    #select sensor and display currently existing calibration points of this sensor and their units
    @Slot()
    def selectSensor(self):
        #fetch selected sensor index from comboBox
        self.selectedSensor = self.ui.sensorSelect.currentIndex()

        #update lineEdits from local storage lists
        self.ui.analogEdit1.setText(str(self.analogValues[self.selectedSensor][0]))
        self.ui.analogEdit2.setText(str(self.analogValues[self.selectedSensor][1]))
        #self.ui.analogEdit3.setText(str(self.analogValues[self.selectedSensor][2]))
        self.ui.digitalEdit1.setText(str(self.digitalValues[self.selectedSensor][0]))
        self.ui.digitalEdit2.setText(str(self.digitalValues[self.selectedSensor][1]))
        #self.ui.digitalEdit3.setText(str(self.digitalValues[self.selectedSensor][2]))

        #get unit by checking if selected sensor index is in pressureIndices list from main window
        if self.selectedSensor in self.collection.mainWindow.pressureIndices:
            self.currentUnit = "Pa"
        else:
            self.currentUnit = "K"

        #update unit labels
        self.ui.unitLabel1.setText(self.currentUnit)
        self.ui.unitLabel2.setText(self.currentUnit)
        #self.ui.unitLabel3.setText(self.currentUnit)

    #enable lineEdit corresponding to selected radioButton, disable the others
    #if "use current digital" is checked, disable digital lineEdits as well, if not enable the one corresponding to selected radioButton
    @Slot()
    def disablingLogic(self):
        #match case structure to check which radio button is selected
        match self.buttonGroup.checkedButton():
            case self.ui.radioButton1:

                #enable corresponding analog lineEdit, disable others
                self.ui.analogEdit1.setEnabled(True)
                self.ui.analogEdit2.setDisabled(True)
                #self.ui.analogEdit3.setDisabled(True)

                #set selectedEntry variable accordingly
                self.selectedEntry = 0

                #if "use current digital" is not checked, enable corresponding digital lineEdit, disable others, if not checked disable all digital lineEdits
                if not self.ui.useCurrentDigital.isChecked():
                    self.ui.digitalEdit1.setEnabled(True)
                else:
                    self.ui.digitalEdit1.setDisabled(True)
                self.ui.digitalEdit2.setDisabled(True)
                #self.ui.digitalEdit3.setDisabled(True)

            #radioButton2 case equivalent to radioButton1
            case self.ui.radioButton2:
                self.ui.analogEdit1.setDisabled(True)
                self.ui.analogEdit2.setEnabled(True)
               # self.ui.analogEdit3.setDisabled(True)
                self.selectedEntry = 1
                self.ui.digitalEdit1.setDisabled(True)
                if not self.ui.useCurrentDigital.isChecked():
                    self.ui.digitalEdit2.setEnabled(True)
                else:
                    self.ui.digitalEdit2.setDisabled(True)
                #self.ui.digitalEdit3.setDisabled(True)

            #radioButton3 case equivalent to radioButton1
            # case self.ui.radioButton3:
            #     self.ui.analogEdit1.setDisabled(True)
            #     self.ui.analogEdit2.setDisabled(True)
            #     self.ui.analogEdit3.setEnabled(True)
            #     self.selectedEntry = 2
            #     self.ui.digitalEdit1.setDisabled(True)
            #     self.ui.digitalEdit2.setDisabled(True)
            #     if not self.ui.useCurrentDigital.isChecked():
            #         self.ui.digitalEdit3.setEnabled(True)
            #     else:
            #         self.ui.digitalEdit3.setDisabled(True)

        #if "use current digital" is checked, the selected sensor will show current digital value in the corresponding digital lineEdit, so call selectSensor for the case that it is now unchecked and the set digital value needs to be updated
        if not self.ui.useCurrentDigital.isChecked():
            self.selectSensor()
    
    #save the currently selected calibration point
    @Slot()
    def newCalibrationPoint(self):
        #initialize temporary variables
        analogValue = 0
        digitalValue = 0

        #fetch analog value from corresponding lineEdit according to selectedEntry and convert string to float
        match self.selectedEntry:
            case 0:
                analogValue = float(self.ui.analogEdit1.text())
            case 1:
                analogValue = float(self.ui.analogEdit2.text())
            # case 2:
            #     analogValue = float(self.ui.analogEdit3.text())

        #save analog value in local storage list
        self.analogValues[self.selectedSensor][self.selectedEntry] = analogValue

        #if use currentDigital is not checked, fetch digital value from corresponding lineEdit according to selectedEntry and convert string to int
        if not self.ui.useCurrentDigital.isChecked():
            match self.selectedEntry:
                case 0:
                    digitalValue = int(self.ui.digitalEdit1.text())
                case 1:
                    digitalValue = int(self.ui.digitalEdit2.text())
                # case 2:
                #     digitalValue = int(self.ui.digitalEdit3.text())

        #if use currentDigital is checked, fetch current digital value from DataAccumulation
        else:
            digitalValue = self.collection.dataAccumulation.currentDigitals[self.selectedSensor]

        #save digital value in local storage list
        self.digitalValues[self.selectedSensor][self.selectedEntry] = digitalValue

        #write calibration point with determined values to Calibration Point savefile using DataHandling function
        DataHandling.WritePoint(self.selectedSensor, self.selectedEntry, digitalValue, analogValue)

        #reselect sensor to update displayed values
        self.selectSensor()

    #update displayed current sensor value when new frame is available
    @Slot(int)
    def onNewFrame(self, index:int):
        self.updateValue(index)

class GSDiagramSettings(QWidget):
    doTaskSignal = Signal(int)

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_diagramSettings()
        self.ui.setupUi(self)
        self.collection = collection
        self.connect()
    
    @Slot()
    def applySettings(self):
        #variable to track if made changes in diagram settings require a complete plot rebuild, False by default
        plotRebuildNecessary = False

        #axis settings, no plot rebuild necessary here as changes will be applied in updateAxes function
        #check if self -scaling is checked, if so, set stored settings accordingly
        if self.ui.pressureSelfScaling.isChecked():
            self.collection.settings.pressureAxeMode = Settings.SELFSCALING
        else:
            #if not, save settings accordingly and fetch fixed axis max-value from lineEdit
            self.collection.settings.pressureAxeMode = Settings.FIXEDVALUE
            self.collection.settings.pressureAxeValue = float(self.ui.pressureLineEdit.text())

        #temperature axis settings equivalent to pressure axis settings
        if self.ui.temperatureSelfScaling.isChecked():
            self.collection.settings.temperatureAxeMode = Settings.SELFSCALING
        else:
            self.collection.settings.temperatureAxeMode = Settings.FIXEDVALUE
            self.collection.settings.temperatureAxeValue = float(self.ui.temperatureLineEdit.text())

        #time span mode settings
        #check if scrolling mode is checked
        if self.ui.scrollingRadioButton.isChecked():

            #if mode was not already in scrolling, set it and mark plot rebuild as necessary
            if self.collection.settings.timespanMode != Settings.SCROLLING:
                plotRebuildNecessary = True
                self.collection.settings.timespanMode = Settings.SCROLLING

            #check if scrolling time has changed, if so, set it and mark plot rebuild as necessary
            if self.collection.settings.scrollingTimeSeconds != int(self.ui.scrollingTimeEdit.time().minute()*60 + self.ui.scrollingTimeEdit.time().second()):
                plotRebuildNecessary = True
                self.collection.settings.scrollingTimeSeconds = int(self.ui.scrollingTimeEdit.time().minute()*60 + self.ui.scrollingTimeEdit.time().second())

            #if both arent True, scrolling mode is activated but no changes were made -> no action necessary

        #if expanding mode is checked
        else:
            #if mode was not already in expanding, set it and mark plot rebuild as necessary
            if self.collection.settings.timespanMode != Settings.EXPANDING:
                plotRebuildNecessary = True
                self.collection.settings.timespanMode = Settings.EXPANDING

            #check if expandFrom value has changed, if so, set it and mark plot rebuild as necessary
            if self.collection.settings.expandFrom != self.ui.firstShownComboBox.currentIndex():
                plotRebuildNecessary = True
                self.collection.settings.expandFrom = self.ui.firstShownComboBox.currentIndex()
        
        #if a plot rebuild is necessary, set rebuildPlot flag in plotWorker and start the worker thread
        if plotRebuildNecessary:
            self.doTaskSignal.emit(PlotWorker.REBUILDPLOT)

        #update axes for potential changes in axis settings
        self.collection.mainWindow.updateAxes()

    #enabling/disabling logic for lineEdits according to selected radio buttons
    @Slot()
    def radioButtonClicked(self):
        #lineEdits only enabled if self-scaling is not checked
        if self.ui.pressureSelfScaling.isChecked():
            self.ui.pressureLineEdit.setDisabled(True)
        else:
            self.ui.pressureLineEdit.setEnabled(True)
        if self.ui.temperatureSelfScaling.isChecked():
            self.ui.temperatureLineEdit.setDisabled(True)
        else:
            self.ui.temperatureLineEdit.setEnabled(True)

        #starting point combo box for expanding mode only enabled if scrolling mode is not checked
        if self.ui.scrollingRadioButton.isChecked():
            self.ui.scrollingTimeEdit.setEnabled(True)
            self.ui.firstShownComboBox.setDisabled(True)
        else:
            self.ui.scrollingTimeEdit.setDisabled(True)
            self.ui.firstShownComboBox.setEnabled(True)

    #connect signals to slots
    def connect(self):
        self.ui.pressureSelfScaling.clicked.connect(self.radioButtonClicked)
        self.ui.pressureFixedValue.clicked.connect(self.radioButtonClicked)
        self.ui.temperatureSelfScaling.clicked.connect(self.radioButtonClicked)
        self.ui.temperatureFixedValue.clicked.connect(self.radioButtonClicked)
        self.ui.scrollingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.scrollingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.expandingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.expandingRadioButton.clicked.connect(self.radioButtonClicked)
        self.ui.applyDiagramSettings.clicked.connect(self.applySettings)

class GSLiveValuesWidget(QWidget):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_LiveValuesWidget()
        self.ui.setupUi(self)
        self.collection = collection
        self.FSAlabel = QLabel(self)
        self.FSAlabel.setFrameShape(QLabel.NoFrame)
        self.FSAlabel.setFrameShadow(QLabel.Plain)
        self.FSAlabel.setScaledContents(False)
        self.FSAlabel.lower()
        #self.pixsize = QSize(421,700)

    def applyLightMode(self):
        #renderer = QSvgRenderer("Resources\\FSDlight.svg")
        pixmap = QPixmap("Resources\\FSDlight.png")
        #pixmap.fill(Qt.transparent)
        #painter = QPainter(pixmap)
        #renderer.render(painter)
        #painter.end()
        self.FSAlabel.setPixmap(pixmap)
        x = (self.width() - pixmap.width()) / 2
        y = (self.height() - pixmap.height()) / 2
        self.FSAlabel.setGeometry(x, y, pixmap.width(), pixmap.height())

    def applyDarkMode(self):
        #renderer = QSvgRenderer("Resources\\FSDdark.svg")
        pixmap = QPixmap("Resources\\FSDdark.png")
        #pixmap.fill(Qt.transparent)
        #painter = QPainter(pixmap)
        #renderer.render(painter)
        #painter.end()
        self.FSAlabel.setPixmap(pixmap)
        x = (self.width() - pixmap.width()) / 2
        y = (self.height() - pixmap.height()) / 2
        self.FSAlabel.setGeometry(x, y, pixmap.width(), pixmap.height())

    @Slot()
    def onNewFrame(self):
        dataAccu = self.collection.dataAccumulation
        self.ui.ambientPressure.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Ambient_Pressure]:.1f} Pa")
        self.ui.coldJunctionTemperature.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Compare_Temperature]:.1f} K")
        self.ui.accumulatorPressure.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Accumulator_Pressure]:.1f} Pa")
        self.ui.accumulatorTemperature.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Accumulator_Temperature]:.1f} K")
        self.ui.chamberPressure.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Chamber_Pressure]:.1f} Pa")
        self.ui.chamberTemperature.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Chamber_Temperature_2]:.1f} K")
        self.ui.nozzlePressure1.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Nozzle_1_Pressure]:.1f} Pa")
        self.ui.nozzleTemperature1.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Nozzle_1_Temperature]:.1f} K")
        self.ui.nozzlePressure2.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Nozzle_2_Pressure]:.1f} Pa")
        self.ui.nozzleTemperature2.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Nozzle_2_Temperature]:.1f} K")
        self.ui.nozzlePressure3.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Nozzle_3_Pressure]:.1f} Pa")
        self.ui.nozzleTemperature3.setText(f"{dataAccu.sensorData[dataAccu.gatherIndex][PyID.Nozzle_3_Temperature]:.1f} K")

class GSExport(QDialog):
    POWON = 0
    LO = 1
    SOE = 2
    EOE = 3
    POWOFF = 4
    HOUSEHOLD = 0
    MEASUREMENT = 1
    ALL = 2

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.ui = Ui_Export()
        self.ui.setupUi(self)
        self.collection = collection
        self.filepath = ""

        self.accepted.connect(self.export)

    @Slot()
    def export(self):
        #open explorer for choosing filepath
        self.filepath = QFileDialog.getSaveFileName(
            self,
            "Save As CSV",
            os.path.join(os.path.expanduser("~"), "Documents"),
            "CSV-files (*.csv)"
        )

        self.collection.exportWorker.start()

class ExportWorker(QThread):
    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.collection = collection

    def run(self):
        filepath = self.collection.exportWindow.filepath

        #if no filepath was chosen, abort
        if not filepath: return

        #find start and end indices of frames according to settings set in export window

        #initialize indices
        startIndex = -1
        endIndex = -1

        #get settings for start and ending point
        startSetting = self.collection.exportWindow.ui.startComboBox.currentIndex()
        endSetting = self.collection.exportWindow.ui.endComboBox.currentIndex() + 1 #shift by 1 as Power On is not an option in End Point Combo Box

        #if if power on is chosen as starting point, start Index should be 0 (the first frame in saveFile)
        if startSetting == GSExport.POWON:
            startIndex = 0

        #initializing frame counter for finding right indices
        currentIndex = 0

        #loop for finding the according start and end indices
        #run until both indices have been found
        while startIndex == -1 or endIndex == -1:

            #Get frame
            frame = DataHandling.GetSaveFrame(currentIndex)

            #abort if all frames have been passed. if endIndex hasnt been set yet, set it to last index
            if DataHandling.FrameIsEmpty(frame):
                if endIndex == -1:
                    endIndex = currentIndex - 1
                break

            #if start Index hasnt been found yet, check if it is found with this frame
            if startIndex == -1:

                #check if first frame should be the lift-Off frame, if so, check if lift off has happenned in the current frame
                if startSetting == GSExport.LO and DataHandling.ReadFrame(frame, TMID.Lift_Off) == 1:

                    #if it has, set the start index accordingly
                    startIndex = currentIndex

                #same logic with SOE, accordingly
                if startSetting == GSExport.SOE and DataHandling.ReadFrame(frame, TMID.Start_Experiment) == 1:
                    startIndex = currentIndex

                #same logic with EOE, accordingly
                if startSetting == GSExport.EOE and DataHandling.ReadFrame(frame, TMID.End_Experiment) == 1:
                    startIndex = currentIndex
            
            #same principle as start Index
            if endIndex == -1:
                if endSetting == GSExport.LO and DataHandling.ReadFrame(frame, TMID.Lift_Off) == 1:
                    endIndex = currentIndex
                if endSetting == GSExport.SOE and DataHandling.ReadFrame(frame, TMID.Start_Experiment) == 1:
                    endIndex = currentIndex
                if endSetting == GSExport.EOE and DataHandling.ReadFrame(frame, TMID.End_Experiment) == 1:
                    endIndex = currentIndex

            #increase currentIndex and continue with next frame in next loop iteration
            currentIndex += 1

            #continue with writing csv file
        

        #open file with set filepath
        with open(filepath, mode="w", newline="", encoding="utf-8") as file:

            #open csv writer for this file
            writer = csv.writer(file, delimiter=";")
        
            #fetch setting for which data should be written
            dataSetting = self.collection.exportWindow.ui.dataComboBox.currentIndex()

            #initialize header
            header = []

            #initialize range of points of interest (first of second half and last of first half by default, at least one of them will be overwritten, so that range is valid)
            firstPoint = TMID.Ambient_Pressure_Health
            lastPoint = TMID.Nozzle_Temperature_3

            #if Measurement data should be included (either exclusively or because all data should be included), add according header strings and set first point to first sensor point
            if dataSetting == GSExport.ALL or dataSetting == GSExport.MEASUREMENT:
                header.extend(["Ambient Pressure", "Compare Temperature", "Accumulator Pressure", "Accumulator Temperature", "Chamber Pressure",
                    "Chamber Temperature 1", "Chamber Temperature 2", "Nozzle Pressure 1", "Nozzle Temperature 1", "Nozzle Pressure 2",
                    "Nozzle Temperature 2", "Nozzle Pressure 3", "Nozzle Temperature 3"])
                firstPoint = TMID.Ambient_Pressure

            #if household data should be included, add according header strings and set last Point to the last household Point
            if dataSetting == GSExport.ALL or dataSetting == GSExport.HOUSEHOLD:
                header.extend(["Ambient Pressure Health", "Compare Temperature Health", "Tank Pressure Health", "Tank Temperature Health",
                    "Chamber Pressure Health", "Chamber Temperature 1 Health", "Chamber Temperature 2 Health", "Nozzle Pressure 1 Health",
                    "Nozzle Temperature 1 Health", "Nozzle Pressure 2 Health", "Nozzle Temperature 2 Health", "Nozzle Pressure 3 Health",
                    "Nozzle_Temperature 3 Health", "Nozzle Open", "Nozzle Closed", "Nozzle Servo", "Reservoir Valve", "Camera", "LEDs",
                    "Sensorboard P", "Sensorboard T", "Mainboard", "Mainboard T", "Mainboard V", "System Time", "Lift Off", "Start Experiment",
                    "End Experiment", "Mode", "Experiment State"])
                lastPoint = TMID.Experiment_State

            #write the header row with the now accumulated entries
            writer.writerow(header)

            #check if indices are valid, write data
            if endIndex >= startIndex:

                #go through all indices that were determined earlier
                for frameIndex in range(startIndex, endIndex + 1):
                    
                    #initialize the row
                    row = []

                    #get the save frame from current Index
                    frame = DataHandling.GetSaveFrame(frameIndex)

                    #go through all point indices that were determined earlier
                    for pointIndex in range(firstPoint, lastPoint + 1):

                        #append point to row
                        row.append(DataHandling.ReadFrame(frame, pointIndex))

                    #write row
                    writer.writerow(row)

        #call GetSaveFrame with newest index, so that internal counting is set back to the newest index and GetNextFrame() works as wanted for DataAccumulation
        DataHandling.GetSaveFrame(-1)

class PlotWorker(QThread):
    replaceSeriesSignal = Signal(int, list)
    clearSeriesSignal = Signal(int)
    updatePlotMetricsSignal = Signal(int, float, float)
    updateTimeAxisSignal = Signal()

    REBUILDPLOT = 1
    REDUCEPOINTS = 2

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.collection = collection

        self.task = 0

    #override run function of QThread, only then will it run on separate thread
    def run(self):
        #check which type of work to do
        if self.task == self.REBUILDPLOT:
            self.doRebuildPlot()
        if self.task == self.REDUCEPOINTS:
            self.doReduceSeries()

    #funtcion that starts the worker with given task, is called from employing class via Signal
    @Slot(int)
    def doTask(self, task: int):
        self.task = task
        self.start()

    def doRebuildPlot(self):
        #fetch necessary data
        settings = self.collection.settings
        dataAcc = self.collection.dataAccumulation
        gatherIndex = dataAcc.gatherIndex
        sensorData = dataAcc.sensorData
        systemTime = dataAcc.systemTime
        mainWindow = self.collection.mainWindow

        #variable to track if plot should be cleared instead of rebuilt
        clear = False

        #determine start and end indices for plot data according to settings
        #start Index 0 by default
        startIndex = 0

        #endIndex should always be gatherIndex (newest index after system time)
        endIndex = dataAcc.gatherIndex

        #start index determination for expaning mode
        if settings.timespanMode == Settings.EXPANDING:
            match settings.expandFrom:
                case Settings.LO:
                    #if liftOffIndex is set, use it as start index, else clear plot, no data should be shown until lift off
                    if dataAcc.liftOffIndex != -1:
                        startIndex = dataAcc.liftOffIndex
                    else:
                        clear = True

                #start index determination for start of experiment same as lift off
                case Settings.SOE:
                    if dataAcc.startOfExperimentIndex != -1:
                        startIndex = dataAcc.startOfExperimentIndex
                    else:
                        clear = True

        #start index determination for scrolling mode
        else:
            #start index is either as many indices from gatherIndex, as fit into scrolling time, or 0 if not enough data points yet
            startIndex = max(0, gatherIndex - (self.collection.dataHandlingThread.frequency * settings.scrollingTimeSeconds))

        #check if endIndex is lower or equal to startIndex, if so, clear plot, should not happen due to previous checks, but just in case
        if endIndex <= startIndex:
            clear = True

        #clear plot if demanded
        if clear:
            for i in range(self.collection.mainWindow.sensorSize):
                self.clearSeriesSignal.emit(i)
            return
        
        #if startIndex is 0, relevant data can be sliced from full array directly
        if startIndex == 0:
            xValues = systemTime[:endIndex]
            yMatrix = sensorData[:endIndex, :DataAccumulation.sensorSize]

        #for arbitrary startIndex, slicing needs to be done with ascontiguousarray
        else:
            xValues = np.ascontiguousarray(systemTime[startIndex:endIndex])
            yMatrix = np.ascontiguousarray(sensorData[startIndex:endIndex, :DataAccumulation.sensorSize])

        #for every sensor, create list of QPointF from x and y values and replace time series data in main window
        for i in range(DataAccumulation.sensorSize):
            #get y values of this sensor from previously sliced yMatrix
            yValues =  yMatrix[:, i]

            #create list of QPointF from x and y values
            points = [QPointF(x, y) for x, y in zip(xValues, yValues)]

            #reduce number of points if necessary
            while len(points) > self.collection.settings.maxPlotPoints:
                points = self.reduceArray(points)

            #replace time series data in main window
            self.replaceSeriesSignal.emit(i, points)

        #update main window variables for highest pressure, highest temperature and currently newest global Index
        self.updatePlotMetricsSignal.emit(gatherIndex, np.max(yMatrix[:, self.collection.mainWindow.pressureIndices]), np.max(yMatrix[:, self.collection.mainWindow.temperatureIndices]))

        #update the time range on the x-axis
        self.updateTimeAxisSignal.emit()

        #reset rebuildPlot flag
        self.rebuildPlot = False

    #reduces number of points in time series by averaging every two points in the left 2/3 of the series
    def doReduceSeries(self):

        #go through all time series to reduce their points
        for seriesIndex, series in enumerate(self.collection.mainWindow.timeSeries):

            #convert QLineSeries to array of QPointF
            points = series.points()

            reducedPoints = self.reduceArray(points)

            self.replaceSeriesSignal.emit(seriesIndex, reducedPoints)

    #putting actual reducing functionality in separate function, so it can be used in both doRebuildPlot and doReduceSeries
    def reduceArray(self, points: list[QPointF]):
        length = len(points)

        #split the series at 2/3 length into left and right part
        splitIndex = (2 * length) // 3
        left = points[:splitIndex]
        right = points[splitIndex:]

        #initialize reduced left part
        reducedLeft = []

        for i in range(0, len(left) - 1, 2):
            point1 = left[i]
            point2 = left[i+1]

            reducedLeft.append(QPointF((point1.x() + point2.x()) / 2, (point1.y() + point2.y()) / 2))

        if len(left) % 2 != 0:
            reducedLeft.append(left[-1])

        return (reducedLeft + right)

#class for accumulating incoming data frames and sorting them into numpy arrays
class DataAccumulation(QObject):
    #signal emitted when a new frame has been processed, sends the index of the new data point in the arrays to interested slots
    newFrameSignal = Signal(int)
    statusDisplaySignal = Signal(int)
    setConnectionStatusSignal = Signal(int)
    setPowerOnTimeSignal = Signal(QDateTime)
    setLOTimeSignal = Signal(QDateTime)
    setSOETimeSignal = Signal(QDateTime)
    setNozzleOpenTimeSignal = Signal(QDateTime)
    setEOETimeSignal = Signal(QDateTime)

    #clearing signals
    clearSeriesSignal = Signal(int)
    updatePlotMetricsSignal = Signal(int, float, float)

    #class variables for amount of sensors and household entries
    sensorSize = 13
    householdSize = 29

    #max digital values of 24-bit and 16-bit sensors for checking invalid data
    MAX24 = (1<<24)-1
    MAX16 = (1<<16)-1

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.collection = collection

        #initialize variables
        self.gatherIndex = -1 #index of the last data point in the arrays (point with highest system time). -1 by default
        self.newIndex = -1 #index of the newly added data point to the arrays. -1 by default
        self.liftOffIndex = -1 #index of the data point corresponding to launch time. -1 by default
        self.startOfExperimentIndex = -1 #index of the data point corresponding to start of experiment. -1 by default
        self.noPacketCount = 0 #counter for number of consecutive empty frames received, used for connection status tracking
        self.allocationSize = 5000 #number of data points to allocate space for in each extension of the arrays

        #initialize data arrays with initial allocation size
        self.sensorData = np.ones((self.allocationSize, self.sensorSize))
        self.household = np.ones(self.householdSize)
        self.systemTime = np.ones(self.allocationSize)

        #variables to keep track of rising edge of LO and SOE, to determine where the corresponding indices should be set
        self.risingEdgeLO = 0
        self.risingEdgeSOE = 0

        #initialize current digitals array. Used for calibration window to get current digital values of sensors, since sensorData only contains mapped analog values
        self.currentDigitals = [1] * self.sensorSize

    def accumulate(self):
        #switch for testing purposes
        testData = True

        #Get Frame and check connection status
        if not testData:
            #make status display red if port is open, purple is port is not open, overrided by frame flags later if packet can be received
            if DataHandling.PortIsOpen():
                self.setConnectionStatusSignal.emit(GSMain.INACTIVE)
            else:
                self.setConnectionStatusSignal.emit(GSMain.NOCONNECTION)

        #while true loop to process multiple consecutive frames, as long as they are available. empty frame will break the loop
        while True:
            if not testData:

                #fetch frame from DataHandling
                frame = DataHandling.GetNextFrame()

                #check if frame is empty
                if DataHandling.FrameIsEmpty(frame):

                    #increase no packet counter
                    self.noPacketCount += 1

                    #if 20 consecutive empty frames have been received, emit status display signal to update connection status in main window and reset no packet counter
                    if self.noPacketCount >= 20:
                        self.statusDisplaySignal.emit(self.gatherIndex)
                        self.noPacketCount = 0

                    #break from loop
                    break

                #at this point, frame is not empty, so if powerOnTime is still None, a rising edge in power is detected and powerOnTime needs to be set
                if self.collection.settings.powerOnTime is None:
                    self.setPowerOnTimeSignal.emit(QDateTime.currentDateTime(self.collection.settings.timeZone))

                #check if frame has OK flag (crc and checksum correct)
                if DataHandling.FrameHasFlag(frame, Flag.OK):

                    #make connection status display green
                    self.setConnectionStatusSignal.emit(GSMain.ACTIVE)

                    #reset no packet counter
                    self.noPacketCount = 0

                    #increase gather index for new data point
                    self.gatherIndex += 1

                    #dont break from loop, continue


                else:
                    #make connection status display yellow, because frame has errors
                    self.setConnectionStatusSignal.emit(GSMain.ISSUES)

                    #update status display in main window
                    self.statusDisplaySignal.emit(self.gatherIndex)

                    #reset no packet counter
                    self.noPacketCount = 0

                    #try to continue to next frame without increasing gather index or entering any of the data into arrays
                    continue

            else:
                ###
                self.gatherIndex += 1 ###only for testing purposes###
                ###

            #extend arrays if necessary
            if self.gatherIndex%self.allocationSize == 0 and self.gatherIndex != 0:

                #create extensions of arrays with allocation size
                dataExtension = np.ones((self.allocationSize, self.sensorSize))
                timeExtension = np.ones(self.allocationSize)

                #concatenate extensions to existing arrays
                self.sensorData = np.concatenate((self.sensorData, dataExtension))
                self.systemTime = np.concatenate((self.systemTime, timeExtension))

            if not testData:
                #if array has no entries yet, or system time of new frame is higher than the last entry in array, new index is simply gather index
                if self.gatherIndex <= 0 or DataHandling.ReadFrame(frame, TMID.System_Time) > self.systemTime[self.gatherIndex - 1]:
                    self.newIndex = self.gatherIndex

                #in other case, find correct index for new data point by searching sorted system time array
                else:
                    self.newIndex = np.searchsorted(self.systemTime[:self.gatherIndex], DataHandling.ReadFrame(frame, TMID.System_Time))

            else:
                ###
                self.newIndex = self.gatherIndex ###only for testing purposes###
                ###

            #go through all sensors and read their values from frame, map them and store them in sensorData array at newIndex
            for i in range(self.sensorSize):

                if testData:
                    ###
                    self.sensorData[self.newIndex][i] = int(150*sin(radians((10*self.newIndex)%360 + 10*i))+150) ###only for testing purposes###
                    ###

                else:
                    #store mapped sensor value in sensorData array
                    self.sensorData[self.newIndex][i] = DataHandling.MapSensorValue(i, DataHandling.ReadFrame(frame, i))

                    #store unmapped digital value in currentDigitals array for calibration window
                    self.currentDigitals[i] = DataHandling.ReadFrame(frame, i)

            if not testData:
                #save system time
                self.systemTime[self.newIndex] = DataHandling.ReadFrame(frame, TMID.System_Time) / 1000

                #special case for accumulator pressure, override it as sum of itself and ambient pressure, as it is a relative pressure sensor
                self.sensorData[self.newIndex][PyID.Accumulator_Pressure] = self.sensorData[self.newIndex][PyID.Accumulator_Pressure] + self.sensorData[self.newIndex][PyID.Ambient_Pressure]

                #Due to difficulties with the adcs, chamber 1 temperature adc has been permanently hijacked for reading cold junction -> copy chamber 1 temp to compare temp
                self.sensorData[self.newIndex][PyID.Compare_Temperature] = self.sensorData[self.newIndex][PyID.Chamber_Temperature_1]

                #override all thermocouple values with the sum of themselves and compare temperature, as they are relative temp sensors
                for sensorIndex in [PyID.Accumulator_Temperature, PyID.Nozzle_1_Temperature, PyID.Nozzle_2_Temperature, PyID.Nozzle_3_Temperature]:
                    self.sensorData[self.newIndex][sensorIndex] = self.sensorData[self.newIndex][sensorIndex] + self.sensorData[self.newIndex][PyID.Compare_Temperature]
                    
            if testData:
                ###
                self.systemTime[self.newIndex] = 1/self.collection.dataHandlingThread.frequency*self.gatherIndex  ###only for testing purposes###
                ###

                self.newFrameSignal.emit(int(self.newIndex))
                self.statusDisplaySignal.emit(self.gatherIndex)

                break

            else:
                #check health of all sensors by checking their values for plausability, only if new frame is most recent frame
                if self.newIndex == self.gatherIndex:
                    for i in range(self.sensorSize):

                        #fetch current and last value of sensor
                        currentVal = self.sensorData[self.gatherIndex][i]
                        lastVal = self.sensorData[self.gatherIndex-1][i]

                        #check if current value hasnt changed (not plausible) -> mark as ISSUES (yellow)
                        if currentVal == lastVal:
                            self.household[i] = GSMain.ISSUES

                        #in other case, mark as ACTIVE (green)
                        else:
                            self.household[i] = GSMain.ACTIVE

                        #check if sensor is ambient pressure sensor or accumulator pressure sensor as they are the only 24-bit sensors
                        if i == PyID.Ambient_Pressure or i == PyID.Accumulator_Pressure:

                            #if current value is either max 24-bit value or 0, mark as INACTIVE (red)
                            if self.currentDigitals[i] == self.MAX24 or self.currentDigitals[i] == 0:
                                self.household[i] = GSMain.INACTIVE

                        #in other case, for 16-bit sensors
                        else:

                            #if current value is either max 16-bit value or 0, mark as INACTIVE (red)
                            if self.currentDigitals[i] == self.MAX16 or self.currentDigitals[i] == 0:
                                self.household[i] = GSMain.INACTIVE

                    #go through all household entries, read their values from frame and store them in household array at newIndex, also only if frame is most recent frame
                    self.household[PyID.Nozzle_Open] = DataHandling.ReadFrame(frame, TMID.Nozzle_Open)
                    self.household[PyID.Nozzle_Closed] = DataHandling.ReadFrame(frame, TMID.Nozzle_Closed)
                    self.household[PyID.Nozzle_Servo] = DataHandling.ReadFrame(frame, TMID.Nozzle_Servo)
                    self.household[PyID.Reservoir_Valve] = DataHandling.ReadFrame(frame, TMID.Reservoir_Valve)
                    self.household[PyID.LEDs] = DataHandling.ReadFrame(frame, TMID.LEDs)
                    self.household[PyID.Sensorboard_P] = DataHandling.ReadFrame(frame, TMID.Sensorboard_P)
                    self.household[PyID.Sensorboard_T] = DataHandling.ReadFrame(frame, TMID.Sensorboard_T)
                    self.household[PyID.Mainboard_T] = DataHandling.ReadFrame(frame, TMID.Mainboard_T)
                    self.household[PyID.Mainboard_V] = DataHandling.ReadFrame(frame, TMID.Mainboard_V)
                    self.household[PyID.System_Time] = DataHandling.ReadFrame(frame, TMID.System_Time) / 1000
                    self.household[PyID.Lift_Off] = DataHandling.ReadFrame(frame, TMID.Lift_Off)
                    self.household[PyID.Start_Experiment] = DataHandling.ReadFrame(frame, TMID.Start_Experiment)
                    self.household[PyID.End_Experiment] = DataHandling.ReadFrame(frame, TMID.End_Experiment)
                    self.household[PyID.Mode] = DataHandling.ReadFrame(frame, TMID.Mode)
                    self.household[PyID.Experiment_State] = DataHandling.ReadFrame(frame, TMID.Experiment_State)

                #if gatherIndex is not 0, check for rising edges of lift off and start of experiment values to store their indices in settings
                #extra if term, so that times are always set, even when progressBar reset was called manually. liftOffIndex should only be set during an actual rising Edge
                if self.gatherIndex > 0:
                    if (self.collection.settings.LOTime is None) and self.household[PyID.Lift_Off] == 1:
                        self.setLOTimeSignal.emit(QDateTime.currentDateTime(self.collection.settings.timeZone))
                        if self.risingEdgeLO == 0:
                            self.liftOffIndex = self.gatherIndex
                            self.risingEdgeLO = 1
                    if (self.collection.settings.SOETime is None) and self.household[PyID.Start_Experiment] == 1:
                        self.setSOETimeSignal.emit(QDateTime.currentDateTime(self.collection.settings.timeZone))
                        if self.risingEdgeSOE == 0:
                            self.startOfExperimentIndex = self.gatherIndex
                            self.risingEdgeSOE = 1

                #set cover open time in settings, if cover open signal is received and cover open time has not been written yet
                if self.household[PyID.Nozzle_Open] == 1 and self.collection.settings.nozzleOpenTime is None:
                    self.setNozzleOpenTimeSignal.emit(QDateTime.currentDateTime(self.collection.settings.timeZone))
                
                #set EOE time in settings, if EOE Signal is received and EOETime has not been written yet
                if self.household[PyID.End_Experiment] == 1 and self.collection.settings.EOETime is None:
                    self.setEOETimeSignal.emit(QDateTime.currentDateTime(self.collection.settings.timeZone))

                #reset risingEdge trackers if falling edge is detected, reset ProgressBars on falling edge of LO
                if self.risingEdgeLO == 1 and self.household[PyID.Lift_Off] == 0:
                    self.risingEdgeLO = 0
                if self.risingEdgeSOE == 1 and self.household[PyID.Start_Experiment] == 0:
                    self.risingEdgeSOE = 0

            #emit new frame signal for graph and calibration window updates
            self.newFrameSignal.emit(int(self.newIndex))

            #emit status display signal
            self.statusDisplaySignal.emit(self.gatherIndex)

            if testData:
                ###
                break ###only for testing purposes###
                ###

    def clearData(self):
        #initialize variables
        self.gatherIndex = -1 #index of the last data point in the arrays (point with highest system time). -1 by default
        self.newIndex = -1 #index of the newly added data point to the arrays. -1 by default
        self.liftOffIndex = -1 #index of the data point corresponding to launch time. -1 by default
        self.startOfExperimentIndex = -1 #index of the data point corresponding to start of experiment. -1 by default
        self.noPacketCount = 0 #counter for number of consecutive empty frames received, used for connection status tracking

        #initialize data arrays with initial allocation size
        self.sensorData = np.ones((self.allocationSize, self.sensorSize))
        self.household = np.ones(self.householdSize)
        self.systemTime = np.ones(self.allocationSize)

        #variables to keep track of rising edge of LO and SOE, to determine where the corresponding indices should be set
        self.risingEdgeLO = 0
        self.risingEdgeSOE = 0

        self.setPowerOnTimeSignal.emit(None)
        self.setLOTimeSignal.emit(None)
        self.setSOETimeSignal.emit(None)
        self.setNozzleOpenTimeSignal.emit(None)
        self.setEOETimeSignal.emit(None)

        for i in range(self.sensorSize):
            self.clearSeriesSignal.emit(i)
        self.updatePlotMetricsSignal.emit(0, 0, 0)

#class that hosts the DataHandling loop in a separate thread
class DataHandlingThread(QThread):
    sendStepSignal = Signal()
    updateProgressBarSignal = Signal()
    updateLOTimerSignal = Signal()

    def __init__(self, collection: ClassCollection):
        super().__init__()
        self.collection = collection

        #frequency of DataHandling loop in Hz
        self.frequency = 20

    #override run function of QThread, is triggered from GSStart when DataHandlingThread.start() is called
    def run(self):
        #calculate period in milliseconds from frequency
        period_ms = 1000 / self.frequency

        #i = 0 ###only for debugging
        #times = [0]*50 ###only for debugging

        #initialize DataHandling
        DataHandling.Initialize(
            bytes(self.collection.settings.filePath, "utf-8"),
            bytes(self.collection.settings.calibrationPath, "utf-8"),
            bytes(self.collection.settings.connector, "utf-8"),
            1,
            1
        )

        #main loop
        while True:
            #get starting time of loop iteration
            clock = time.monotonic_ns()

            #DataHandling.DebugLastFrame()####only for debugging

            #make all updates in DataHandling
            DataHandling.UpdateAll()

            # clock2 = time.monotonic_ns()
            # print("DataHandlingUpdate-time: " + str((clock2-clock)/1000000))

            #accumulate and sort incoming data frames into python local numpy arrays
            self.collection.dataAccumulation.accumulate()

            # clock3 = time.monotonic_ns()
            # print("dataAcc-time: " + str((clock3-clock2)/1000000))

            #send telecommand step
            self.sendStepSignal.emit()

            #update progress bar
            self.updateProgressBarSignal.emit()
            self.updateLOTimerSignal.emit()

            # clock4 = time.monotonic_ns()
            # print("tc-time: " + str((clock4-clock3)/1000000))
            # clock5 = time.monotonic_ns()
            # print("signal-emit-time: " + str((clock5-clock4)/1000000))

            #cleanly exit thread if interruption is requested
            if self.isInterruptionRequested():
                DataHandling.CloseAll()
                break

            #get end time of loop iteration
            endTime = time.monotonic_ns()

            # print(period_ms-(endTime - clock)/1000000)

            #sleep for remaining period time if loop iteration was faster than period
            if (endTime - clock)/1000000 < period_ms:
                time.sleep((period_ms - (endTime - clock) / 1000000)/1000)

            #clock6 = time.monotonic_ns() ####only for debugging
            # print("rest-time: " + str((clock6-clock5)/1000000))

            #debugging loop time measurement
            #times[i] = (clock6-clock)/1000000
            #i += 1
            #if i == 50:
            #    average = 0
            #    for timeVal in times:
            #        average += timeVal
            #    average = average/50
            #    print("DataHandling Loop-time average: " + str(average) + " with " + str(self.collection.dataAccumulation.gatherIndex + 1) + " points\n")
            #    i = 0

#class that collects all instantiated classes and connects them as necessary
#other classes only need to have access to this class to access other classes
class ClassCollection:
    def __init__(self):
        self.settings = Settings()
        self.telecommand = Telecommand(self)
        self.dataAccumulation = DataAccumulation(self)
        self.mainWindow = GSMain(self)
        self.startWindow = GSStart(self)
        self.controlPanel = GSControl(self)
        self.timeWindow = GSLaunchTime(self)
        self.errorWindow = GSError(self)
        self.connectionWindow = GSConnection(self)
        self.calibrationWindow = GSCalibration(self)
        self.plotWorker = PlotWorker(self)
        self.diagramSettingsWindow = GSDiagramSettings(self)
        self.exportWorker = ExportWorker(self)
        self.exportWindow = GSExport(self)
        self.liveValuesWidget = GSLiveValuesWidget(self)

        #connect onNewFrame signals
        self.dataAccumulation.newFrameSignal.connect(self.mainWindow.onNewFrame)
        self.dataAccumulation.newFrameSignal.connect(self.calibrationWindow.onNewFrame)
        self.dataAccumulation.newFrameSignal.connect(self.liveValuesWidget.onNewFrame)

        #connect statusDisplaySignal and setConnectionStatusSignal, as well set time signals
        self.dataAccumulation.statusDisplaySignal.connect(self.mainWindow.displayStatus)
        self.dataAccumulation.setConnectionStatusSignal.connect(self.mainWindow.setConnectionStatus)
        self.dataAccumulation.setPowerOnTimeSignal.connect(self.settings.setPowerOnTime)
        self.dataAccumulation.setLOTimeSignal.connect(self.settings.setLOTime)
        self.dataAccumulation.setSOETimeSignal.connect(self.settings.setSOETime)
        self.dataAccumulation.setNozzleOpenTimeSignal.connect(self.settings.setNozzleOpenTime)
        self.dataAccumulation.setEOETimeSignal.connect(self.settings.setEOETime)

        self.dataAccumulation.clearSeriesSignal.connect(self.mainWindow.clearSeries)
        self.dataAccumulation.updatePlotMetricsSignal.connect(self.mainWindow.updatePlotMetrics)

        #connect doTask signals to plotWorker
        self.mainWindow.doTaskSignal.connect(self.plotWorker.doTask)
        self.diagramSettingsWindow.doTaskSignal.connect(self.plotWorker.doTask)

        #connect signals from plotWorker to slots in mainWindow that keep the threads seperated
        self.plotWorker.replaceSeriesSignal.connect(self.mainWindow.replaceSeries)
        self.plotWorker.clearSeriesSignal.connect(self.mainWindow.clearSeries)
        self.plotWorker.updatePlotMetricsSignal.connect(self.mainWindow.updatePlotMetrics)
        self.plotWorker.updateTimeAxisSignal.connect(self.mainWindow.updateTimeAxis)

        #DataHandling setup
        self.dataHandlingThread = DataHandlingThread(self)

        #Signal for sending telecommand step from DataHandling thread to Telecommand class and signal for updating ProgressBar from dataHandlingThread to main Window
        self.dataHandlingThread.sendStepSignal.connect(self.telecommand.sendStep)
        self.dataHandlingThread.updateProgressBarSignal.connect(self.mainWindow.updateProgressBar)
        self.dataHandlingThread.updateLOTimerSignal.connect(self.mainWindow.updateLOTimer)

    #inter-window connections
    def interWindowConnection(self):
        self.mainWindow.ui.actionRestart.triggered.connect(self.startWindow.show)
        self.mainWindow.ui.actionRestart.triggered.connect(self.mainWindow.hide)
        self.mainWindow.ui.actionControl_Panel.triggered.connect(self.controlPanel.show)
        self.mainWindow.ui.actionConnection.triggered.connect(self.connectionWindow.show)
        self.mainWindow.ui.actionEstimated_Launch_Time.triggered.connect(self.timeWindow.show)
        self.startWindow.accepted.connect(self.mainWindow.applySettings)
        self.startWindow.accepted.connect(self.mainWindow.show)
        self.timeWindow.accepted.connect(self.mainWindow.applySettings)
        self.mainWindow.ui.actionCalibration.triggered.connect(self.calibrationWindow.show)
        self.mainWindow.ui.actionDiagrams.triggered.connect(self.diagramSettingsWindow.show)
        self.mainWindow.ui.actionExport.triggered.connect(self.exportWindow.show)
        self.mainWindow.ui.actionLive_Values_Widget.triggered.connect(self.liveValuesWidget.show)

    #shutdown procedure to stop DataHandling thread cleanly
    def shutdown(self):
        #request interruption of DataHandling thread, thread is running to the point at which it reacts to the interruption request and closes
        thread = self.dataHandlingThread
        thread.requestInterruption()

        #get QApplication instance
        app = QApplication.instance()

        #initialize timeout variables
        timeout_ms = 5000
        interval_ms = 50
        waited = 0

        #process events and wait until thread has stopped or timeout is reached
        while thread.isRunning() and waited < timeout_ms:
            app.processEvents()
            time.sleep(interval_ms/1000)
            waited += interval_ms

        #finally quit application
        app.quit()

#Main program
if __name__ == "__main__":
    #initialize QApplication
    GS = QApplication()

    #initialize application icon
    icon = QIcon("Resources\\meega_logo_small.ico")
    GS.setWindowIcon(icon)

    #initialize style
    GS.setStyle(QStyleFactory.create("Windows11"))

    #initialize translator and set default locale to C
    translator = QTranslator()
    QLocale.setDefault(QLocale.C)

    #initialize class collection, which in turn initializes all other classes
    collection = ClassCollection()

    #set theme to the same as OS theme
    try:
        keyPath = r'Software\Microsoft\Windows\CurrentVersion\Themes\Personalize'
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, keyPath) as key:
            appsUseLightTheme, _ = winreg.QueryValueEx(key, 'AppsUseLightTheme')
            if appsUseLightTheme == 1:
                collection.mainWindow.setLightTheme()
            else:
                collection.mainWindow.setDarkTheme()
    except OSError:
        collection.mainWindow.setLightTheme()

    #install translator according to selected locale in settings
    if translator.load(collection.settings.locale, "MEEGA_Language"):
        GS.installTranslator(translator)

    #perform inter-window connections
    collection.interWindowConnection()
    
    #showing the startup screen
    collection.startWindow.show()

    #starting the PyQt Application Loop (everything has to be defined prior to this)
    sys.exit(GS.exec())
#End